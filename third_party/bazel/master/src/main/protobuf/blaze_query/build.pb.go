// Code generated by protoc-gen-go. DO NOT EDIT.
// source: third_party/bazel/master/src/main/protobuf/build.proto

/*
Package blaze_query is a generated protocol buffer package.

It is generated from these files:
	third_party/bazel/master/src/main/protobuf/build.proto

It has these top-level messages:
	License
	StringDictEntry
	LabelDictUnaryEntry
	LabelListDictEntry
	LabelKeyedStringDictEntry
	StringListDictEntry
	FilesetEntry
	Attribute
	Rule
	AttributeAspect
	SkylarkAspect
	RuleSummary
	PackageGroup
	EnvironmentGroup
	SourceFile
	GeneratedFile
	Target
	QueryResult
	AllowedRuleClassInfo
	AttributeDefinition
	RuleDefinition
	BuildLanguage
	Location
	MakeVarBinding
	MakeVar
	GlobCriteria
	Event
*/
package blaze_query

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// Indicates what to do when a source file is actually a symlink.
type FilesetEntry_SymlinkBehavior int32

const (
	FilesetEntry_COPY        FilesetEntry_SymlinkBehavior = 1
	FilesetEntry_DEREFERENCE FilesetEntry_SymlinkBehavior = 2
)

var FilesetEntry_SymlinkBehavior_name = map[int32]string{
	1: "COPY",
	2: "DEREFERENCE",
}
var FilesetEntry_SymlinkBehavior_value = map[string]int32{
	"COPY":        1,
	"DEREFERENCE": 2,
}

func (x FilesetEntry_SymlinkBehavior) Enum() *FilesetEntry_SymlinkBehavior {
	p := new(FilesetEntry_SymlinkBehavior)
	*p = x
	return p
}
func (x FilesetEntry_SymlinkBehavior) String() string {
	return proto.EnumName(FilesetEntry_SymlinkBehavior_name, int32(x))
}
func (x *FilesetEntry_SymlinkBehavior) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(FilesetEntry_SymlinkBehavior_value, data, "FilesetEntry_SymlinkBehavior")
	if err != nil {
		return err
	}
	*x = FilesetEntry_SymlinkBehavior(value)
	return nil
}
func (FilesetEntry_SymlinkBehavior) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor0, []int{6, 0}
}

// Indicates the type of attribute.
type Attribute_Discriminator int32

const (
	Attribute_INTEGER                      Attribute_Discriminator = 1
	Attribute_STRING                       Attribute_Discriminator = 2
	Attribute_LABEL                        Attribute_Discriminator = 3
	Attribute_OUTPUT                       Attribute_Discriminator = 4
	Attribute_STRING_LIST                  Attribute_Discriminator = 5
	Attribute_LABEL_LIST                   Attribute_Discriminator = 6
	Attribute_OUTPUT_LIST                  Attribute_Discriminator = 7
	Attribute_DISTRIBUTION_SET             Attribute_Discriminator = 8
	Attribute_LICENSE                      Attribute_Discriminator = 9
	Attribute_STRING_DICT                  Attribute_Discriminator = 10
	Attribute_FILESET_ENTRY_LIST           Attribute_Discriminator = 11
	Attribute_LABEL_LIST_DICT              Attribute_Discriminator = 12
	Attribute_STRING_LIST_DICT             Attribute_Discriminator = 13
	Attribute_BOOLEAN                      Attribute_Discriminator = 14
	Attribute_TRISTATE                     Attribute_Discriminator = 15
	Attribute_INTEGER_LIST                 Attribute_Discriminator = 16
	Attribute_UNKNOWN                      Attribute_Discriminator = 18
	Attribute_LABEL_DICT_UNARY             Attribute_Discriminator = 19
	Attribute_SELECTOR_LIST                Attribute_Discriminator = 20
	Attribute_LABEL_KEYED_STRING_DICT      Attribute_Discriminator = 21
	Attribute_DEPRECATED_STRING_DICT_UNARY Attribute_Discriminator = 17
)

var Attribute_Discriminator_name = map[int32]string{
	1:  "INTEGER",
	2:  "STRING",
	3:  "LABEL",
	4:  "OUTPUT",
	5:  "STRING_LIST",
	6:  "LABEL_LIST",
	7:  "OUTPUT_LIST",
	8:  "DISTRIBUTION_SET",
	9:  "LICENSE",
	10: "STRING_DICT",
	11: "FILESET_ENTRY_LIST",
	12: "LABEL_LIST_DICT",
	13: "STRING_LIST_DICT",
	14: "BOOLEAN",
	15: "TRISTATE",
	16: "INTEGER_LIST",
	18: "UNKNOWN",
	19: "LABEL_DICT_UNARY",
	20: "SELECTOR_LIST",
	21: "LABEL_KEYED_STRING_DICT",
	17: "DEPRECATED_STRING_DICT_UNARY",
}
var Attribute_Discriminator_value = map[string]int32{
	"INTEGER":                      1,
	"STRING":                       2,
	"LABEL":                        3,
	"OUTPUT":                       4,
	"STRING_LIST":                  5,
	"LABEL_LIST":                   6,
	"OUTPUT_LIST":                  7,
	"DISTRIBUTION_SET":             8,
	"LICENSE":                      9,
	"STRING_DICT":                  10,
	"FILESET_ENTRY_LIST":           11,
	"LABEL_LIST_DICT":              12,
	"STRING_LIST_DICT":             13,
	"BOOLEAN":                      14,
	"TRISTATE":                     15,
	"INTEGER_LIST":                 16,
	"UNKNOWN":                      18,
	"LABEL_DICT_UNARY":             19,
	"SELECTOR_LIST":                20,
	"LABEL_KEYED_STRING_DICT":      21,
	"DEPRECATED_STRING_DICT_UNARY": 17,
}

func (x Attribute_Discriminator) Enum() *Attribute_Discriminator {
	p := new(Attribute_Discriminator)
	*p = x
	return p
}
func (x Attribute_Discriminator) String() string {
	return proto.EnumName(Attribute_Discriminator_name, int32(x))
}
func (x *Attribute_Discriminator) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(Attribute_Discriminator_value, data, "Attribute_Discriminator")
	if err != nil {
		return err
	}
	*x = Attribute_Discriminator(value)
	return nil
}
func (Attribute_Discriminator) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{7, 0} }

// Values for the TriState field type.
type Attribute_Tristate int32

const (
	Attribute_NO   Attribute_Tristate = 0
	Attribute_YES  Attribute_Tristate = 1
	Attribute_AUTO Attribute_Tristate = 2
)

var Attribute_Tristate_name = map[int32]string{
	0: "NO",
	1: "YES",
	2: "AUTO",
}
var Attribute_Tristate_value = map[string]int32{
	"NO":   0,
	"YES":  1,
	"AUTO": 2,
}

func (x Attribute_Tristate) Enum() *Attribute_Tristate {
	p := new(Attribute_Tristate)
	*p = x
	return p
}
func (x Attribute_Tristate) String() string {
	return proto.EnumName(Attribute_Tristate_name, int32(x))
}
func (x *Attribute_Tristate) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(Attribute_Tristate_value, data, "Attribute_Tristate")
	if err != nil {
		return err
	}
	*x = Attribute_Tristate(value)
	return nil
}
func (Attribute_Tristate) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{7, 1} }

type Target_Discriminator int32

const (
	Target_RULE              Target_Discriminator = 1
	Target_SOURCE_FILE       Target_Discriminator = 2
	Target_GENERATED_FILE    Target_Discriminator = 3
	Target_PACKAGE_GROUP     Target_Discriminator = 4
	Target_ENVIRONMENT_GROUP Target_Discriminator = 5
)

var Target_Discriminator_name = map[int32]string{
	1: "RULE",
	2: "SOURCE_FILE",
	3: "GENERATED_FILE",
	4: "PACKAGE_GROUP",
	5: "ENVIRONMENT_GROUP",
}
var Target_Discriminator_value = map[string]int32{
	"RULE":              1,
	"SOURCE_FILE":       2,
	"GENERATED_FILE":    3,
	"PACKAGE_GROUP":     4,
	"ENVIRONMENT_GROUP": 5,
}

func (x Target_Discriminator) Enum() *Target_Discriminator {
	p := new(Target_Discriminator)
	*p = x
	return p
}
func (x Target_Discriminator) String() string {
	return proto.EnumName(Target_Discriminator_name, int32(x))
}
func (x *Target_Discriminator) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(Target_Discriminator_value, data, "Target_Discriminator")
	if err != nil {
		return err
	}
	*x = Target_Discriminator(value)
	return nil
}
func (Target_Discriminator) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{16, 0} }

type AllowedRuleClassInfo_AllowedRuleClasses int32

const (
	AllowedRuleClassInfo_ANY       AllowedRuleClassInfo_AllowedRuleClasses = 1
	AllowedRuleClassInfo_SPECIFIED AllowedRuleClassInfo_AllowedRuleClasses = 2
)

var AllowedRuleClassInfo_AllowedRuleClasses_name = map[int32]string{
	1: "ANY",
	2: "SPECIFIED",
}
var AllowedRuleClassInfo_AllowedRuleClasses_value = map[string]int32{
	"ANY":       1,
	"SPECIFIED": 2,
}

func (x AllowedRuleClassInfo_AllowedRuleClasses) Enum() *AllowedRuleClassInfo_AllowedRuleClasses {
	p := new(AllowedRuleClassInfo_AllowedRuleClasses)
	*p = x
	return p
}
func (x AllowedRuleClassInfo_AllowedRuleClasses) String() string {
	return proto.EnumName(AllowedRuleClassInfo_AllowedRuleClasses_name, int32(x))
}
func (x *AllowedRuleClassInfo_AllowedRuleClasses) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(AllowedRuleClassInfo_AllowedRuleClasses_value, data, "AllowedRuleClassInfo_AllowedRuleClasses")
	if err != nil {
		return err
	}
	*x = AllowedRuleClassInfo_AllowedRuleClasses(value)
	return nil
}
func (AllowedRuleClassInfo_AllowedRuleClasses) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor0, []int{18, 0}
}

type Event_EventKind int32

const (
	Event_ERROR    Event_EventKind = 1
	Event_WARNING  Event_EventKind = 2
	Event_INFO     Event_EventKind = 3
	Event_PROGRESS Event_EventKind = 4
)

var Event_EventKind_name = map[int32]string{
	1: "ERROR",
	2: "WARNING",
	3: "INFO",
	4: "PROGRESS",
}
var Event_EventKind_value = map[string]int32{
	"ERROR":    1,
	"WARNING":  2,
	"INFO":     3,
	"PROGRESS": 4,
}

func (x Event_EventKind) Enum() *Event_EventKind {
	p := new(Event_EventKind)
	*p = x
	return p
}
func (x Event_EventKind) String() string {
	return proto.EnumName(Event_EventKind_name, int32(x))
}
func (x *Event_EventKind) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(Event_EventKind_value, data, "Event_EventKind")
	if err != nil {
		return err
	}
	*x = Event_EventKind(value)
	return nil
}
func (Event_EventKind) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{26, 0} }

type License struct {
	LicenseType      []string `protobuf:"bytes,1,rep,name=license_type,json=licenseType" json:"license_type,omitempty"`
	Exception        []string `protobuf:"bytes,2,rep,name=exception" json:"exception,omitempty"`
	XXX_unrecognized []byte   `json:"-"`
}

func (m *License) Reset()                    { *m = License{} }
func (m *License) String() string            { return proto.CompactTextString(m) }
func (*License) ProtoMessage()               {}
func (*License) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *License) GetLicenseType() []string {
	if m != nil {
		return m.LicenseType
	}
	return nil
}

func (m *License) GetException() []string {
	if m != nil {
		return m.Exception
	}
	return nil
}

type StringDictEntry struct {
	Key              *string `protobuf:"bytes,1,req,name=key" json:"key,omitempty"`
	Value            *string `protobuf:"bytes,2,req,name=value" json:"value,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *StringDictEntry) Reset()                    { *m = StringDictEntry{} }
func (m *StringDictEntry) String() string            { return proto.CompactTextString(m) }
func (*StringDictEntry) ProtoMessage()               {}
func (*StringDictEntry) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *StringDictEntry) GetKey() string {
	if m != nil && m.Key != nil {
		return *m.Key
	}
	return ""
}

func (m *StringDictEntry) GetValue() string {
	if m != nil && m.Value != nil {
		return *m.Value
	}
	return ""
}

type LabelDictUnaryEntry struct {
	Key              *string `protobuf:"bytes,1,req,name=key" json:"key,omitempty"`
	Value            *string `protobuf:"bytes,2,req,name=value" json:"value,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *LabelDictUnaryEntry) Reset()                    { *m = LabelDictUnaryEntry{} }
func (m *LabelDictUnaryEntry) String() string            { return proto.CompactTextString(m) }
func (*LabelDictUnaryEntry) ProtoMessage()               {}
func (*LabelDictUnaryEntry) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *LabelDictUnaryEntry) GetKey() string {
	if m != nil && m.Key != nil {
		return *m.Key
	}
	return ""
}

func (m *LabelDictUnaryEntry) GetValue() string {
	if m != nil && m.Value != nil {
		return *m.Value
	}
	return ""
}

type LabelListDictEntry struct {
	Key              *string  `protobuf:"bytes,1,req,name=key" json:"key,omitempty"`
	Value            []string `protobuf:"bytes,2,rep,name=value" json:"value,omitempty"`
	XXX_unrecognized []byte   `json:"-"`
}

func (m *LabelListDictEntry) Reset()                    { *m = LabelListDictEntry{} }
func (m *LabelListDictEntry) String() string            { return proto.CompactTextString(m) }
func (*LabelListDictEntry) ProtoMessage()               {}
func (*LabelListDictEntry) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *LabelListDictEntry) GetKey() string {
	if m != nil && m.Key != nil {
		return *m.Key
	}
	return ""
}

func (m *LabelListDictEntry) GetValue() []string {
	if m != nil {
		return m.Value
	}
	return nil
}

type LabelKeyedStringDictEntry struct {
	Key              *string `protobuf:"bytes,1,req,name=key" json:"key,omitempty"`
	Value            *string `protobuf:"bytes,2,req,name=value" json:"value,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *LabelKeyedStringDictEntry) Reset()                    { *m = LabelKeyedStringDictEntry{} }
func (m *LabelKeyedStringDictEntry) String() string            { return proto.CompactTextString(m) }
func (*LabelKeyedStringDictEntry) ProtoMessage()               {}
func (*LabelKeyedStringDictEntry) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *LabelKeyedStringDictEntry) GetKey() string {
	if m != nil && m.Key != nil {
		return *m.Key
	}
	return ""
}

func (m *LabelKeyedStringDictEntry) GetValue() string {
	if m != nil && m.Value != nil {
		return *m.Value
	}
	return ""
}

type StringListDictEntry struct {
	Key              *string  `protobuf:"bytes,1,req,name=key" json:"key,omitempty"`
	Value            []string `protobuf:"bytes,2,rep,name=value" json:"value,omitempty"`
	XXX_unrecognized []byte   `json:"-"`
}

func (m *StringListDictEntry) Reset()                    { *m = StringListDictEntry{} }
func (m *StringListDictEntry) String() string            { return proto.CompactTextString(m) }
func (*StringListDictEntry) ProtoMessage()               {}
func (*StringListDictEntry) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *StringListDictEntry) GetKey() string {
	if m != nil && m.Key != nil {
		return *m.Key
	}
	return ""
}

func (m *StringListDictEntry) GetValue() []string {
	if m != nil {
		return m.Value
	}
	return nil
}

// Represents an entry attribute of a Fileset rule in a build file.
type FilesetEntry struct {
	// The label pointing to the source target where files are copied from.
	Source *string `protobuf:"bytes,1,req,name=source" json:"source,omitempty"`
	// The relative path within the fileset rule where files will be mapped.
	DestinationDirectory *string `protobuf:"bytes,2,req,name=destination_directory,json=destinationDirectory" json:"destination_directory,omitempty"`
	// Whether the files= attribute was specified. This is necessary because
	// no files= attribute and files=[] mean different things.
	FilesPresent *bool `protobuf:"varint,7,opt,name=files_present,json=filesPresent" json:"files_present,omitempty"`
	// A list of file labels to include from the source directory.
	File []string `protobuf:"bytes,3,rep,name=file" json:"file,omitempty"`
	// If this is a fileset entry representing files within the rule
	// package, this lists relative paths to files that should be excluded from
	// the set.  This cannot contain values if 'file' also has values.
	Exclude []string `protobuf:"bytes,4,rep,name=exclude" json:"exclude,omitempty"`
	// This field is optional because there will be some time when the new
	// PB is used by tools depending on blaze query, but the new blaze version
	// is not yet released.
	// TODO(bazel-team): Make this field required once a version of Blaze is
	// released that outputs this field.
	SymlinkBehavior *FilesetEntry_SymlinkBehavior `protobuf:"varint,5,opt,name=symlink_behavior,json=symlinkBehavior,enum=blaze_query.FilesetEntry_SymlinkBehavior,def=1" json:"symlink_behavior,omitempty"`
	// The prefix to strip from the path of the files in this FilesetEntry. Note
	// that no value and the empty string as the value mean different things here.
	StripPrefix      *string `protobuf:"bytes,6,opt,name=strip_prefix,json=stripPrefix" json:"strip_prefix,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *FilesetEntry) Reset()                    { *m = FilesetEntry{} }
func (m *FilesetEntry) String() string            { return proto.CompactTextString(m) }
func (*FilesetEntry) ProtoMessage()               {}
func (*FilesetEntry) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

const Default_FilesetEntry_SymlinkBehavior FilesetEntry_SymlinkBehavior = FilesetEntry_COPY

func (m *FilesetEntry) GetSource() string {
	if m != nil && m.Source != nil {
		return *m.Source
	}
	return ""
}

func (m *FilesetEntry) GetDestinationDirectory() string {
	if m != nil && m.DestinationDirectory != nil {
		return *m.DestinationDirectory
	}
	return ""
}

func (m *FilesetEntry) GetFilesPresent() bool {
	if m != nil && m.FilesPresent != nil {
		return *m.FilesPresent
	}
	return false
}

func (m *FilesetEntry) GetFile() []string {
	if m != nil {
		return m.File
	}
	return nil
}

func (m *FilesetEntry) GetExclude() []string {
	if m != nil {
		return m.Exclude
	}
	return nil
}

func (m *FilesetEntry) GetSymlinkBehavior() FilesetEntry_SymlinkBehavior {
	if m != nil && m.SymlinkBehavior != nil {
		return *m.SymlinkBehavior
	}
	return Default_FilesetEntry_SymlinkBehavior
}

func (m *FilesetEntry) GetStripPrefix() string {
	if m != nil && m.StripPrefix != nil {
		return *m.StripPrefix
	}
	return ""
}

// A rule attribute. Each attribute must have a type and one of the various
// value fields populated - for the most part.
//
// Attributes of BOOLEAN and TRISTATE type may set all of the int, bool, and
// string values for backwards compatibility with clients that expect them to
// be set.
//
// Attributes of INTEGER, STRING, LABEL, LICENSE, BOOLEAN, and TRISTATE type
// may set *none* of the values. This can happen if the Attribute message is
// prepared for a client that doesn't support SELECTOR_LIST, but the rule has
// a selector list value for the attribute. (Selector lists for attributes of
// other types--the collection types--are handled differently when prepared
// for such a client. The possible collection values are gathered together
// and flattened.)
//
// By checking the type, the appropriate value can be extracted - see the
// comments on each type for the associated value.  The order of lists comes
// from the blaze parsing. If an attribute is of a list type, the associated
// list should never be empty.
type Attribute struct {
	// The name of the attribute
	Name *string `protobuf:"bytes,1,req,name=name" json:"name,omitempty"`
	// The location of the target in the BUILD file in a machine-parseable form.
	DEPRECATEDParseableLocation *Location `protobuf:"bytes,12,opt,name=DEPRECATED_parseable_location,json=DEPRECATEDParseableLocation" json:"DEPRECATED_parseable_location,omitempty"`
	// Whether the attribute was explicitly specified
	ExplicitlySpecified *bool `protobuf:"varint,13,opt,name=explicitly_specified,json=explicitlySpecified" json:"explicitly_specified,omitempty"`
	// If this attribute has a string value or a string list value, then this
	// may be set to indicate that the value may be treated as a label that
	// isn't a dependency of this attribute's rule.
	Nodep *bool `protobuf:"varint,20,opt,name=nodep" json:"nodep,omitempty"`
	// The type of attribute.  This message is used for all of the different
	// attribute types so the discriminator helps for figuring out what is
	// stored in the message.
	Type *Attribute_Discriminator `protobuf:"varint,2,req,name=type,enum=blaze_query.Attribute_Discriminator" json:"type,omitempty"`
	// If this attribute has an integer value this will be populated.
	// Boolean and TriState also use this field as [0,1] and [-1,0,1]
	// for [false, true] and [auto, no, yes] respectively.
	IntValue *int32 `protobuf:"varint,3,opt,name=int_value,json=intValue" json:"int_value,omitempty"`
	// If the attribute has a string value this will be populated.  Label and
	// path attributes use this field as the value even though the type may
	// be LABEL or something else other than STRING.
	StringValue *string `protobuf:"bytes,5,opt,name=string_value,json=stringValue" json:"string_value,omitempty"`
	// If the attribute has a boolean value this will be populated.
	BooleanValue *bool `protobuf:"varint,14,opt,name=boolean_value,json=booleanValue" json:"boolean_value,omitempty"`
	// If the attribute is a Tristate value, this will be populated.
	TristateValue *Attribute_Tristate `protobuf:"varint,15,opt,name=tristate_value,json=tristateValue,enum=blaze_query.Attribute_Tristate" json:"tristate_value,omitempty"`
	// The value of the attribute has a list of string values (label and path
	// note from STRING applies here as well).
	StringListValue []string `protobuf:"bytes,6,rep,name=string_list_value,json=stringListValue" json:"string_list_value,omitempty"`
	// If this is a license attribute, the license information is stored here.
	License *License `protobuf:"bytes,7,opt,name=license" json:"license,omitempty"`
	// If this is a string dict, each entry will be stored here.
	StringDictValue []*StringDictEntry `protobuf:"bytes,8,rep,name=string_dict_value,json=stringDictValue" json:"string_dict_value,omitempty"`
	// If the attribute is part of a Fileset, the fileset entries are stored in
	// this field.
	FilesetListValue []*FilesetEntry `protobuf:"bytes,9,rep,name=fileset_list_value,json=filesetListValue" json:"fileset_list_value,omitempty"`
	// If this is a label list dict, each entry will be stored here.
	LabelListDictValue []*LabelListDictEntry `protobuf:"bytes,10,rep,name=label_list_dict_value,json=labelListDictValue" json:"label_list_dict_value,omitempty"`
	// If this is a string list dict, each entry will be stored here.
	StringListDictValue []*StringListDictEntry `protobuf:"bytes,11,rep,name=string_list_dict_value,json=stringListDictValue" json:"string_list_dict_value,omitempty"`
	// The glob criteria. This is non-empty if:
	// 1. This attribute is a list of strings or labels, and,
	// 2. It contained a glob() expression
	GlobCriteria []*GlobCriteria `protobuf:"bytes,16,rep,name=glob_criteria,json=globCriteria" json:"glob_criteria,omitempty"`
	// The value of the attribute has a list of int32 values
	IntListValue []int32 `protobuf:"varint,17,rep,name=int_list_value,json=intListValue" json:"int_list_value,omitempty"`
	// If this is a label dict unary, each entry will be stored here.
	LabelDictUnaryValue []*LabelDictUnaryEntry `protobuf:"bytes,19,rep,name=label_dict_unary_value,json=labelDictUnaryValue" json:"label_dict_unary_value,omitempty"`
	// If this is a label-keyed string dict, each entry will be stored here.
	LabelKeyedStringDictValue []*LabelKeyedStringDictEntry `protobuf:"bytes,22,rep,name=label_keyed_string_dict_value,json=labelKeyedStringDictValue" json:"label_keyed_string_dict_value,omitempty"`
	// If this attribute's value is an expression containing one or more select
	// expressions, then its type is SELECTOR_LIST and a SelectorList will be
	// stored here.
	SelectorList                   *Attribute_SelectorList `protobuf:"bytes,21,opt,name=selector_list,json=selectorList" json:"selector_list,omitempty"`
	DEPRECATEDStringDictUnaryValue [][]byte                `protobuf:"bytes,18,rep,name=DEPRECATED_string_dict_unary_value,json=DEPRECATEDStringDictUnaryValue" json:"DEPRECATED_string_dict_unary_value,omitempty"`
	XXX_unrecognized               []byte                  `json:"-"`
}

func (m *Attribute) Reset()                    { *m = Attribute{} }
func (m *Attribute) String() string            { return proto.CompactTextString(m) }
func (*Attribute) ProtoMessage()               {}
func (*Attribute) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

func (m *Attribute) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *Attribute) GetDEPRECATEDParseableLocation() *Location {
	if m != nil {
		return m.DEPRECATEDParseableLocation
	}
	return nil
}

func (m *Attribute) GetExplicitlySpecified() bool {
	if m != nil && m.ExplicitlySpecified != nil {
		return *m.ExplicitlySpecified
	}
	return false
}

func (m *Attribute) GetNodep() bool {
	if m != nil && m.Nodep != nil {
		return *m.Nodep
	}
	return false
}

func (m *Attribute) GetType() Attribute_Discriminator {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return Attribute_INTEGER
}

func (m *Attribute) GetIntValue() int32 {
	if m != nil && m.IntValue != nil {
		return *m.IntValue
	}
	return 0
}

func (m *Attribute) GetStringValue() string {
	if m != nil && m.StringValue != nil {
		return *m.StringValue
	}
	return ""
}

func (m *Attribute) GetBooleanValue() bool {
	if m != nil && m.BooleanValue != nil {
		return *m.BooleanValue
	}
	return false
}

func (m *Attribute) GetTristateValue() Attribute_Tristate {
	if m != nil && m.TristateValue != nil {
		return *m.TristateValue
	}
	return Attribute_NO
}

func (m *Attribute) GetStringListValue() []string {
	if m != nil {
		return m.StringListValue
	}
	return nil
}

func (m *Attribute) GetLicense() *License {
	if m != nil {
		return m.License
	}
	return nil
}

func (m *Attribute) GetStringDictValue() []*StringDictEntry {
	if m != nil {
		return m.StringDictValue
	}
	return nil
}

func (m *Attribute) GetFilesetListValue() []*FilesetEntry {
	if m != nil {
		return m.FilesetListValue
	}
	return nil
}

func (m *Attribute) GetLabelListDictValue() []*LabelListDictEntry {
	if m != nil {
		return m.LabelListDictValue
	}
	return nil
}

func (m *Attribute) GetStringListDictValue() []*StringListDictEntry {
	if m != nil {
		return m.StringListDictValue
	}
	return nil
}

func (m *Attribute) GetGlobCriteria() []*GlobCriteria {
	if m != nil {
		return m.GlobCriteria
	}
	return nil
}

func (m *Attribute) GetIntListValue() []int32 {
	if m != nil {
		return m.IntListValue
	}
	return nil
}

func (m *Attribute) GetLabelDictUnaryValue() []*LabelDictUnaryEntry {
	if m != nil {
		return m.LabelDictUnaryValue
	}
	return nil
}

func (m *Attribute) GetLabelKeyedStringDictValue() []*LabelKeyedStringDictEntry {
	if m != nil {
		return m.LabelKeyedStringDictValue
	}
	return nil
}

func (m *Attribute) GetSelectorList() *Attribute_SelectorList {
	if m != nil {
		return m.SelectorList
	}
	return nil
}

func (m *Attribute) GetDEPRECATEDStringDictUnaryValue() [][]byte {
	if m != nil {
		return m.DEPRECATEDStringDictUnaryValue
	}
	return nil
}

type Attribute_SelectorEntry struct {
	// The key of the selector entry. At this time, this is the label of a
	// config_setting rule, or the pseudo-label "//conditions:default".
	Label *string `protobuf:"bytes,1,opt,name=label" json:"label,omitempty"`
	// True if the entry's value is the default value for the type as a
	// result of the condition value being specified as None (ie:
	// {"//condition": None}).
	IsDefaultValue *bool `protobuf:"varint,16,opt,name=is_default_value,json=isDefaultValue" json:"is_default_value,omitempty"`
	// Exactly one of the following fields (except for glob_criteria) must be
	// populated - note that the BOOLEAN and TRISTATE caveat in Attribute's
	// comment does not apply here. The type field in the SelectorList
	// containing this entry indicates which of these fields is populated,
	// in accordance with the comments on Discriminator enum values above.
	// (To be explicit: BOOLEAN populates the boolean_value field and TRISTATE
	// populates the tristate_value field.)
	IntValue                       *int32                       `protobuf:"varint,2,opt,name=int_value,json=intValue" json:"int_value,omitempty"`
	StringValue                    *string                      `protobuf:"bytes,3,opt,name=string_value,json=stringValue" json:"string_value,omitempty"`
	BooleanValue                   *bool                        `protobuf:"varint,4,opt,name=boolean_value,json=booleanValue" json:"boolean_value,omitempty"`
	TristateValue                  *Attribute_Tristate          `protobuf:"varint,5,opt,name=tristate_value,json=tristateValue,enum=blaze_query.Attribute_Tristate" json:"tristate_value,omitempty"`
	StringListValue                []string                     `protobuf:"bytes,6,rep,name=string_list_value,json=stringListValue" json:"string_list_value,omitempty"`
	License                        *License                     `protobuf:"bytes,7,opt,name=license" json:"license,omitempty"`
	StringDictValue                []*StringDictEntry           `protobuf:"bytes,8,rep,name=string_dict_value,json=stringDictValue" json:"string_dict_value,omitempty"`
	FilesetListValue               []*FilesetEntry              `protobuf:"bytes,9,rep,name=fileset_list_value,json=filesetListValue" json:"fileset_list_value,omitempty"`
	LabelListDictValue             []*LabelListDictEntry        `protobuf:"bytes,10,rep,name=label_list_dict_value,json=labelListDictValue" json:"label_list_dict_value,omitempty"`
	StringListDictValue            []*StringListDictEntry       `protobuf:"bytes,11,rep,name=string_list_dict_value,json=stringListDictValue" json:"string_list_dict_value,omitempty"`
	GlobCriteria                   []*GlobCriteria              `protobuf:"bytes,12,rep,name=glob_criteria,json=globCriteria" json:"glob_criteria,omitempty"`
	IntListValue                   []int32                      `protobuf:"varint,13,rep,name=int_list_value,json=intListValue" json:"int_list_value,omitempty"`
	LabelDictUnaryValue            []*LabelDictUnaryEntry       `protobuf:"bytes,15,rep,name=label_dict_unary_value,json=labelDictUnaryValue" json:"label_dict_unary_value,omitempty"`
	LabelKeyedStringDictValue      []*LabelKeyedStringDictEntry `protobuf:"bytes,17,rep,name=label_keyed_string_dict_value,json=labelKeyedStringDictValue" json:"label_keyed_string_dict_value,omitempty"`
	DEPRECATEDStringDictUnaryValue [][]byte                     `protobuf:"bytes,14,rep,name=DEPRECATED_string_dict_unary_value,json=DEPRECATEDStringDictUnaryValue" json:"DEPRECATED_string_dict_unary_value,omitempty"`
	XXX_unrecognized               []byte                       `json:"-"`
}

func (m *Attribute_SelectorEntry) Reset()                    { *m = Attribute_SelectorEntry{} }
func (m *Attribute_SelectorEntry) String() string            { return proto.CompactTextString(m) }
func (*Attribute_SelectorEntry) ProtoMessage()               {}
func (*Attribute_SelectorEntry) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7, 0} }

func (m *Attribute_SelectorEntry) GetLabel() string {
	if m != nil && m.Label != nil {
		return *m.Label
	}
	return ""
}

func (m *Attribute_SelectorEntry) GetIsDefaultValue() bool {
	if m != nil && m.IsDefaultValue != nil {
		return *m.IsDefaultValue
	}
	return false
}

func (m *Attribute_SelectorEntry) GetIntValue() int32 {
	if m != nil && m.IntValue != nil {
		return *m.IntValue
	}
	return 0
}

func (m *Attribute_SelectorEntry) GetStringValue() string {
	if m != nil && m.StringValue != nil {
		return *m.StringValue
	}
	return ""
}

func (m *Attribute_SelectorEntry) GetBooleanValue() bool {
	if m != nil && m.BooleanValue != nil {
		return *m.BooleanValue
	}
	return false
}

func (m *Attribute_SelectorEntry) GetTristateValue() Attribute_Tristate {
	if m != nil && m.TristateValue != nil {
		return *m.TristateValue
	}
	return Attribute_NO
}

func (m *Attribute_SelectorEntry) GetStringListValue() []string {
	if m != nil {
		return m.StringListValue
	}
	return nil
}

func (m *Attribute_SelectorEntry) GetLicense() *License {
	if m != nil {
		return m.License
	}
	return nil
}

func (m *Attribute_SelectorEntry) GetStringDictValue() []*StringDictEntry {
	if m != nil {
		return m.StringDictValue
	}
	return nil
}

func (m *Attribute_SelectorEntry) GetFilesetListValue() []*FilesetEntry {
	if m != nil {
		return m.FilesetListValue
	}
	return nil
}

func (m *Attribute_SelectorEntry) GetLabelListDictValue() []*LabelListDictEntry {
	if m != nil {
		return m.LabelListDictValue
	}
	return nil
}

func (m *Attribute_SelectorEntry) GetStringListDictValue() []*StringListDictEntry {
	if m != nil {
		return m.StringListDictValue
	}
	return nil
}

func (m *Attribute_SelectorEntry) GetGlobCriteria() []*GlobCriteria {
	if m != nil {
		return m.GlobCriteria
	}
	return nil
}

func (m *Attribute_SelectorEntry) GetIntListValue() []int32 {
	if m != nil {
		return m.IntListValue
	}
	return nil
}

func (m *Attribute_SelectorEntry) GetLabelDictUnaryValue() []*LabelDictUnaryEntry {
	if m != nil {
		return m.LabelDictUnaryValue
	}
	return nil
}

func (m *Attribute_SelectorEntry) GetLabelKeyedStringDictValue() []*LabelKeyedStringDictEntry {
	if m != nil {
		return m.LabelKeyedStringDictValue
	}
	return nil
}

func (m *Attribute_SelectorEntry) GetDEPRECATEDStringDictUnaryValue() [][]byte {
	if m != nil {
		return m.DEPRECATEDStringDictUnaryValue
	}
	return nil
}

type Attribute_Selector struct {
	// The list of (label, value) pairs in the map that defines the selector.
	// At this time, this cannot be empty, i.e. a selector has at least one
	// entry.
	Entries []*Attribute_SelectorEntry `protobuf:"bytes,1,rep,name=entries" json:"entries,omitempty"`
	// Whether or not this has any default values.
	HasDefaultValue *bool `protobuf:"varint,2,opt,name=has_default_value,json=hasDefaultValue" json:"has_default_value,omitempty"`
	// The error message when no condition matches.
	NoMatchError     *string `protobuf:"bytes,3,opt,name=no_match_error,json=noMatchError" json:"no_match_error,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *Attribute_Selector) Reset()                    { *m = Attribute_Selector{} }
func (m *Attribute_Selector) String() string            { return proto.CompactTextString(m) }
func (*Attribute_Selector) ProtoMessage()               {}
func (*Attribute_Selector) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7, 1} }

func (m *Attribute_Selector) GetEntries() []*Attribute_SelectorEntry {
	if m != nil {
		return m.Entries
	}
	return nil
}

func (m *Attribute_Selector) GetHasDefaultValue() bool {
	if m != nil && m.HasDefaultValue != nil {
		return *m.HasDefaultValue
	}
	return false
}

func (m *Attribute_Selector) GetNoMatchError() string {
	if m != nil && m.NoMatchError != nil {
		return *m.NoMatchError
	}
	return ""
}

type Attribute_SelectorList struct {
	// The type that this selector list evaluates to, and the type that each
	// selector in the list evaluates to. At this time, this cannot be
	// SELECTOR_LIST, i.e. selector lists do not nest.
	Type *Attribute_Discriminator `protobuf:"varint,1,opt,name=type,enum=blaze_query.Attribute_Discriminator" json:"type,omitempty"`
	// The list of selector elements in this selector list. At this time, this
	// cannot be empty, i.e. a selector list is never empty.
	Elements         []*Attribute_Selector `protobuf:"bytes,2,rep,name=elements" json:"elements,omitempty"`
	XXX_unrecognized []byte                `json:"-"`
}

func (m *Attribute_SelectorList) Reset()                    { *m = Attribute_SelectorList{} }
func (m *Attribute_SelectorList) String() string            { return proto.CompactTextString(m) }
func (*Attribute_SelectorList) ProtoMessage()               {}
func (*Attribute_SelectorList) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7, 2} }

func (m *Attribute_SelectorList) GetType() Attribute_Discriminator {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return Attribute_INTEGER
}

func (m *Attribute_SelectorList) GetElements() []*Attribute_Selector {
	if m != nil {
		return m.Elements
	}
	return nil
}

// A rule from a BUILD file (e.g., cc_library, java_binary).  The rule class
// is the actual name of the rule (e.g., cc_library) and the name is the full
// label of the rule (e.g., //foo/bar:baz).
type Rule struct {
	// The name of the rule
	Name *string `protobuf:"bytes,1,req,name=name" json:"name,omitempty"`
	// The rule class (e.g., java_library)
	RuleClass *string `protobuf:"bytes,2,req,name=rule_class,json=ruleClass" json:"rule_class,omitempty"`
	// The BUILD file and line number of the rule.
	Location *string `protobuf:"bytes,3,opt,name=location" json:"location,omitempty"`
	// All of the attributes that describe the rule.
	Attribute []*Attribute `protobuf:"bytes,4,rep,name=attribute" json:"attribute,omitempty"`
	// All of the inputs to the rule.  These are predecessors in the dependency
	// graph.  A rule_input for a rule should always be described as a
	// source_file in some package (either the rule's package or some other one).
	RuleInput []string `protobuf:"bytes,5,rep,name=rule_input,json=ruleInput" json:"rule_input,omitempty"`
	// All of the outputs of the rule.  These are the successors in the
	// dependency graph.
	RuleOutput []string `protobuf:"bytes,6,rep,name=rule_output,json=ruleOutput" json:"rule_output,omitempty"`
	// The set of all default settings affecting this rule. The name of a default
	// setting is "<setting type>_<setting name>". There currently defined setting
	// types are:
	//
	// - 'blaze': settings implemented in Blaze itself
	DefaultSetting []string `protobuf:"bytes,7,rep,name=default_setting,json=defaultSetting" json:"default_setting,omitempty"`
	// The location of the target in the BUILD file in a machine-parseable form.
	DEPRECATEDParseableLocation *Location `protobuf:"bytes,8,opt,name=DEPRECATED_parseable_location,json=DEPRECATEDParseableLocation" json:"DEPRECATED_parseable_location,omitempty"`
	// The rule's class's public by default value.
	PublicByDefault *bool `protobuf:"varint,9,opt,name=public_by_default,json=publicByDefault" json:"public_by_default,omitempty"`
	// If this rule is of a skylark-defined RuleClass.
	IsSkylark *bool `protobuf:"varint,10,opt,name=is_skylark,json=isSkylark" json:"is_skylark,omitempty"`
	// List of Skylark aspects that this rule applies.
	SkylarkAttributeAspects []*AttributeAspect `protobuf:"bytes,11,rep,name=skylark_attribute_aspects,json=skylarkAttributeAspects" json:"skylark_attribute_aspects,omitempty"`
	// Hash encapsulating the behavior of this Skylark rule. Any change to this
	// rule's definition that could change its behavior will be reflected here.
	SkylarkEnvironmentHashCode *string `protobuf:"bytes,12,opt,name=skylark_environment_hash_code,json=skylarkEnvironmentHashCode" json:"skylark_environment_hash_code,omitempty"`
	XXX_unrecognized           []byte  `json:"-"`
}

func (m *Rule) Reset()                    { *m = Rule{} }
func (m *Rule) String() string            { return proto.CompactTextString(m) }
func (*Rule) ProtoMessage()               {}
func (*Rule) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

func (m *Rule) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *Rule) GetRuleClass() string {
	if m != nil && m.RuleClass != nil {
		return *m.RuleClass
	}
	return ""
}

func (m *Rule) GetLocation() string {
	if m != nil && m.Location != nil {
		return *m.Location
	}
	return ""
}

func (m *Rule) GetAttribute() []*Attribute {
	if m != nil {
		return m.Attribute
	}
	return nil
}

func (m *Rule) GetRuleInput() []string {
	if m != nil {
		return m.RuleInput
	}
	return nil
}

func (m *Rule) GetRuleOutput() []string {
	if m != nil {
		return m.RuleOutput
	}
	return nil
}

func (m *Rule) GetDefaultSetting() []string {
	if m != nil {
		return m.DefaultSetting
	}
	return nil
}

func (m *Rule) GetDEPRECATEDParseableLocation() *Location {
	if m != nil {
		return m.DEPRECATEDParseableLocation
	}
	return nil
}

func (m *Rule) GetPublicByDefault() bool {
	if m != nil && m.PublicByDefault != nil {
		return *m.PublicByDefault
	}
	return false
}

func (m *Rule) GetIsSkylark() bool {
	if m != nil && m.IsSkylark != nil {
		return *m.IsSkylark
	}
	return false
}

func (m *Rule) GetSkylarkAttributeAspects() []*AttributeAspect {
	if m != nil {
		return m.SkylarkAttributeAspects
	}
	return nil
}

func (m *Rule) GetSkylarkEnvironmentHashCode() string {
	if m != nil && m.SkylarkEnvironmentHashCode != nil {
		return *m.SkylarkEnvironmentHashCode
	}
	return ""
}

// A pairing of attribute name and a Skylark aspect that is applied to that attribute.
type AttributeAspect struct {
	AttributeName    *string        `protobuf:"bytes,1,req,name=attribute_name,json=attributeName" json:"attribute_name,omitempty"`
	Aspect           *SkylarkAspect `protobuf:"bytes,2,req,name=aspect" json:"aspect,omitempty"`
	XXX_unrecognized []byte         `json:"-"`
}

func (m *AttributeAspect) Reset()                    { *m = AttributeAspect{} }
func (m *AttributeAspect) String() string            { return proto.CompactTextString(m) }
func (*AttributeAspect) ProtoMessage()               {}
func (*AttributeAspect) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9} }

func (m *AttributeAspect) GetAttributeName() string {
	if m != nil && m.AttributeName != nil {
		return *m.AttributeName
	}
	return ""
}

func (m *AttributeAspect) GetAspect() *SkylarkAspect {
	if m != nil {
		return m.Aspect
	}
	return nil
}

// Aspect defined in Skylark.
type SkylarkAspect struct {
	ExtensionFileLabel *string      `protobuf:"bytes,1,req,name=extension_file_label,json=extensionFileLabel" json:"extension_file_label,omitempty"`
	ExportedName       *string      `protobuf:"bytes,2,req,name=exported_name,json=exportedName" json:"exported_name,omitempty"`
	Attribute          []*Attribute `protobuf:"bytes,3,rep,name=attribute" json:"attribute,omitempty"`
	XXX_unrecognized   []byte       `json:"-"`
}

func (m *SkylarkAspect) Reset()                    { *m = SkylarkAspect{} }
func (m *SkylarkAspect) String() string            { return proto.CompactTextString(m) }
func (*SkylarkAspect) ProtoMessage()               {}
func (*SkylarkAspect) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{10} }

func (m *SkylarkAspect) GetExtensionFileLabel() string {
	if m != nil && m.ExtensionFileLabel != nil {
		return *m.ExtensionFileLabel
	}
	return ""
}

func (m *SkylarkAspect) GetExportedName() string {
	if m != nil && m.ExportedName != nil {
		return *m.ExportedName
	}
	return ""
}

func (m *SkylarkAspect) GetAttribute() []*Attribute {
	if m != nil {
		return m.Attribute
	}
	return nil
}

// Summary of all transitive dependencies of 'rule,' where each dependent
// rule is included only once in the 'dependency' field.  Gives complete
// information to analyze the single build target labeled rule.name,
// including optional location of target in BUILD file.
type RuleSummary struct {
	Rule             *Rule   `protobuf:"bytes,1,req,name=rule" json:"rule,omitempty"`
	Dependency       []*Rule `protobuf:"bytes,2,rep,name=dependency" json:"dependency,omitempty"`
	Location         *string `protobuf:"bytes,3,opt,name=location" json:"location,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *RuleSummary) Reset()                    { *m = RuleSummary{} }
func (m *RuleSummary) String() string            { return proto.CompactTextString(m) }
func (*RuleSummary) ProtoMessage()               {}
func (*RuleSummary) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{11} }

func (m *RuleSummary) GetRule() *Rule {
	if m != nil {
		return m.Rule
	}
	return nil
}

func (m *RuleSummary) GetDependency() []*Rule {
	if m != nil {
		return m.Dependency
	}
	return nil
}

func (m *RuleSummary) GetLocation() string {
	if m != nil && m.Location != nil {
		return *m.Location
	}
	return ""
}

// A package group. Aside from the name, it contains the list of packages
// present in the group (as specified in the BUILD file).
type PackageGroup struct {
	// The name of the package group
	Name *string `protobuf:"bytes,1,req,name=name" json:"name,omitempty"`
	// The list of packages as specified in the BUILD file. Currently this is
	// only a list of packages, but some time in the future, there might be
	// some type of wildcard mechanism.
	ContainedPackage []string `protobuf:"bytes,2,rep,name=contained_package,json=containedPackage" json:"contained_package,omitempty"`
	// The list of sub package groups included in this one.
	IncludedPackageGroup []string `protobuf:"bytes,3,rep,name=included_package_group,json=includedPackageGroup" json:"included_package_group,omitempty"`
	// The location of the target in the BUILD file in a machine-parseable form.
	DEPRECATEDParseableLocation *Location `protobuf:"bytes,4,opt,name=DEPRECATED_parseable_location,json=DEPRECATEDParseableLocation" json:"DEPRECATED_parseable_location,omitempty"`
	XXX_unrecognized            []byte    `json:"-"`
}

func (m *PackageGroup) Reset()                    { *m = PackageGroup{} }
func (m *PackageGroup) String() string            { return proto.CompactTextString(m) }
func (*PackageGroup) ProtoMessage()               {}
func (*PackageGroup) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{12} }

func (m *PackageGroup) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *PackageGroup) GetContainedPackage() []string {
	if m != nil {
		return m.ContainedPackage
	}
	return nil
}

func (m *PackageGroup) GetIncludedPackageGroup() []string {
	if m != nil {
		return m.IncludedPackageGroup
	}
	return nil
}

func (m *PackageGroup) GetDEPRECATEDParseableLocation() *Location {
	if m != nil {
		return m.DEPRECATEDParseableLocation
	}
	return nil
}

// An environment group.
type EnvironmentGroup struct {
	// The name of the environment group.
	Name *string `protobuf:"bytes,1,req,name=name" json:"name,omitempty"`
	// The environments that belong to this group (as labels).
	Environment []string `protobuf:"bytes,2,rep,name=environment" json:"environment,omitempty"`
	// The member environments that rules implicitly support if not otherwise
	// specified.
	Default          []string `protobuf:"bytes,3,rep,name=default" json:"default,omitempty"`
	XXX_unrecognized []byte   `json:"-"`
}

func (m *EnvironmentGroup) Reset()                    { *m = EnvironmentGroup{} }
func (m *EnvironmentGroup) String() string            { return proto.CompactTextString(m) }
func (*EnvironmentGroup) ProtoMessage()               {}
func (*EnvironmentGroup) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{13} }

func (m *EnvironmentGroup) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *EnvironmentGroup) GetEnvironment() []string {
	if m != nil {
		return m.Environment
	}
	return nil
}

func (m *EnvironmentGroup) GetDefault() []string {
	if m != nil {
		return m.Default
	}
	return nil
}

// A file that is an input into the build system.
// Next-Id: 10
type SourceFile struct {
	// The name of the source file (a label).
	Name *string `protobuf:"bytes,1,req,name=name" json:"name,omitempty"`
	// The location of the source file.  This is a path with line numbers, not
	// a label in the build system.
	Location *string `protobuf:"bytes,2,opt,name=location" json:"location,omitempty"`
	// The location of the corresponding label in the BUILD file in a
	// machine-parseable form.
	DEPRECATEDParseableLocation *Location `protobuf:"bytes,7,opt,name=DEPRECATED_parseable_location,json=DEPRECATEDParseableLocation" json:"DEPRECATED_parseable_location,omitempty"`
	// Labels of files that are transitively subincluded in this BUILD file. This
	// is present only when the SourceFile represents a BUILD file that
	// subincludes other files. The subincluded file can be either a Python
	// preprocessed build extension or a Skylark file.
	Subinclude []string `protobuf:"bytes,3,rep,name=subinclude" json:"subinclude,omitempty"`
	// Labels of package groups that are mentioned in the visibility declaration
	// for this source file.
	PackageGroup []string `protobuf:"bytes,4,rep,name=package_group,json=packageGroup" json:"package_group,omitempty"`
	// Labels mentioned in the visibility declaration (including :__pkg__ and
	// //visibility: ones)
	VisibilityLabel []string `protobuf:"bytes,5,rep,name=visibility_label,json=visibilityLabel" json:"visibility_label,omitempty"`
	// The package-level features enabled for this package. Only present if the
	// SourceFile represents a BUILD file.
	Feature []string `protobuf:"bytes,6,rep,name=feature" json:"feature,omitempty"`
	// License attribute for the file.
	License *License `protobuf:"bytes,8,opt,name=license" json:"license,omitempty"`
	// True if the package contains an error. Only present if the SourceFile
	// represents a BUILD file.
	PackageContainsErrors *bool  `protobuf:"varint,9,opt,name=package_contains_errors,json=packageContainsErrors" json:"package_contains_errors,omitempty"`
	XXX_unrecognized      []byte `json:"-"`
}

func (m *SourceFile) Reset()                    { *m = SourceFile{} }
func (m *SourceFile) String() string            { return proto.CompactTextString(m) }
func (*SourceFile) ProtoMessage()               {}
func (*SourceFile) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{14} }

func (m *SourceFile) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *SourceFile) GetLocation() string {
	if m != nil && m.Location != nil {
		return *m.Location
	}
	return ""
}

func (m *SourceFile) GetDEPRECATEDParseableLocation() *Location {
	if m != nil {
		return m.DEPRECATEDParseableLocation
	}
	return nil
}

func (m *SourceFile) GetSubinclude() []string {
	if m != nil {
		return m.Subinclude
	}
	return nil
}

func (m *SourceFile) GetPackageGroup() []string {
	if m != nil {
		return m.PackageGroup
	}
	return nil
}

func (m *SourceFile) GetVisibilityLabel() []string {
	if m != nil {
		return m.VisibilityLabel
	}
	return nil
}

func (m *SourceFile) GetFeature() []string {
	if m != nil {
		return m.Feature
	}
	return nil
}

func (m *SourceFile) GetLicense() *License {
	if m != nil {
		return m.License
	}
	return nil
}

func (m *SourceFile) GetPackageContainsErrors() bool {
	if m != nil && m.PackageContainsErrors != nil {
		return *m.PackageContainsErrors
	}
	return false
}

// A file that is the output of a build rule.
type GeneratedFile struct {
	// The name of the generated file (a label).
	Name *string `protobuf:"bytes,1,req,name=name" json:"name,omitempty"`
	// The label of the target that generates the file.
	GeneratingRule *string `protobuf:"bytes,2,req,name=generating_rule,json=generatingRule" json:"generating_rule,omitempty"`
	// The path of the output file (not a label).
	Location         *string `protobuf:"bytes,3,opt,name=location" json:"location,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *GeneratedFile) Reset()                    { *m = GeneratedFile{} }
func (m *GeneratedFile) String() string            { return proto.CompactTextString(m) }
func (*GeneratedFile) ProtoMessage()               {}
func (*GeneratedFile) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{15} }

func (m *GeneratedFile) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *GeneratedFile) GetGeneratingRule() string {
	if m != nil && m.GeneratingRule != nil {
		return *m.GeneratingRule
	}
	return ""
}

func (m *GeneratedFile) GetLocation() string {
	if m != nil && m.Location != nil {
		return *m.Location
	}
	return ""
}

// A target from a blaze query execution.  Similar to the Attribute message,
// the Discriminator is used to determine which field contains information.
// For any given type, only one of these can be populated in a single Target.
type Target struct {
	// The type of target contained in the message.
	Type *Target_Discriminator `protobuf:"varint,1,req,name=type,enum=blaze_query.Target_Discriminator" json:"type,omitempty"`
	// If this target represents a rule, the rule is stored here.
	Rule *Rule `protobuf:"bytes,2,opt,name=rule" json:"rule,omitempty"`
	// A file that is not generated by the build system (version controlled
	// or created by the test harness).
	SourceFile *SourceFile `protobuf:"bytes,3,opt,name=source_file,json=sourceFile" json:"source_file,omitempty"`
	// A generated file that is the output of a rule.
	GeneratedFile *GeneratedFile `protobuf:"bytes,4,opt,name=generated_file,json=generatedFile" json:"generated_file,omitempty"`
	// A package group.
	PackageGroup *PackageGroup `protobuf:"bytes,5,opt,name=package_group,json=packageGroup" json:"package_group,omitempty"`
	// An environment group.
	EnvironmentGroup *EnvironmentGroup `protobuf:"bytes,6,opt,name=environment_group,json=environmentGroup" json:"environment_group,omitempty"`
	XXX_unrecognized []byte            `json:"-"`
}

func (m *Target) Reset()                    { *m = Target{} }
func (m *Target) String() string            { return proto.CompactTextString(m) }
func (*Target) ProtoMessage()               {}
func (*Target) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{16} }

func (m *Target) GetType() Target_Discriminator {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return Target_RULE
}

func (m *Target) GetRule() *Rule {
	if m != nil {
		return m.Rule
	}
	return nil
}

func (m *Target) GetSourceFile() *SourceFile {
	if m != nil {
		return m.SourceFile
	}
	return nil
}

func (m *Target) GetGeneratedFile() *GeneratedFile {
	if m != nil {
		return m.GeneratedFile
	}
	return nil
}

func (m *Target) GetPackageGroup() *PackageGroup {
	if m != nil {
		return m.PackageGroup
	}
	return nil
}

func (m *Target) GetEnvironmentGroup() *EnvironmentGroup {
	if m != nil {
		return m.EnvironmentGroup
	}
	return nil
}

// Container for all of the blaze query results.
type QueryResult struct {
	// All of the targets returned by the blaze query.
	Target           []*Target `protobuf:"bytes,1,rep,name=target" json:"target,omitempty"`
	XXX_unrecognized []byte    `json:"-"`
}

func (m *QueryResult) Reset()                    { *m = QueryResult{} }
func (m *QueryResult) String() string            { return proto.CompactTextString(m) }
func (*QueryResult) ProtoMessage()               {}
func (*QueryResult) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{17} }

func (m *QueryResult) GetTarget() []*Target {
	if m != nil {
		return m.Target
	}
	return nil
}

// Information about allowed rule classes for a specific attribute of a rule.
type AllowedRuleClassInfo struct {
	Policy *AllowedRuleClassInfo_AllowedRuleClasses `protobuf:"varint,1,req,name=policy,enum=blaze_query.AllowedRuleClassInfo_AllowedRuleClasses" json:"policy,omitempty"`
	// Rule class names of rules allowed in this attribute, e.g "cc_library",
	// "py_binary". Only present if the allowed_rule_classes field is set to
	// SPECIFIED.
	AllowedRuleClass []string `protobuf:"bytes,2,rep,name=allowed_rule_class,json=allowedRuleClass" json:"allowed_rule_class,omitempty"`
	XXX_unrecognized []byte   `json:"-"`
}

func (m *AllowedRuleClassInfo) Reset()                    { *m = AllowedRuleClassInfo{} }
func (m *AllowedRuleClassInfo) String() string            { return proto.CompactTextString(m) }
func (*AllowedRuleClassInfo) ProtoMessage()               {}
func (*AllowedRuleClassInfo) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{18} }

func (m *AllowedRuleClassInfo) GetPolicy() AllowedRuleClassInfo_AllowedRuleClasses {
	if m != nil && m.Policy != nil {
		return *m.Policy
	}
	return AllowedRuleClassInfo_ANY
}

func (m *AllowedRuleClassInfo) GetAllowedRuleClass() []string {
	if m != nil {
		return m.AllowedRuleClass
	}
	return nil
}

// This message represents a single attribute of a single rule.
type AttributeDefinition struct {
	// Attribute name, i.e. "name", "srcs", "deps"
	Name      *string                  `protobuf:"bytes,1,req,name=name" json:"name,omitempty"`
	Type      *Attribute_Discriminator `protobuf:"varint,2,req,name=type,enum=blaze_query.Attribute_Discriminator" json:"type,omitempty"`
	Mandatory *bool                    `protobuf:"varint,3,req,name=mandatory" json:"mandatory,omitempty"`
	// Only present for attributes of type LABEL and LABEL_LIST.
	AllowedRuleClasses *AllowedRuleClassInfo `protobuf:"bytes,4,opt,name=allowed_rule_classes,json=allowedRuleClasses" json:"allowed_rule_classes,omitempty"`
	Documentation      *string               `protobuf:"bytes,5,opt,name=documentation" json:"documentation,omitempty"`
	XXX_unrecognized   []byte                `json:"-"`
}

func (m *AttributeDefinition) Reset()                    { *m = AttributeDefinition{} }
func (m *AttributeDefinition) String() string            { return proto.CompactTextString(m) }
func (*AttributeDefinition) ProtoMessage()               {}
func (*AttributeDefinition) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{19} }

func (m *AttributeDefinition) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *AttributeDefinition) GetType() Attribute_Discriminator {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return Attribute_INTEGER
}

func (m *AttributeDefinition) GetMandatory() bool {
	if m != nil && m.Mandatory != nil {
		return *m.Mandatory
	}
	return false
}

func (m *AttributeDefinition) GetAllowedRuleClasses() *AllowedRuleClassInfo {
	if m != nil {
		return m.AllowedRuleClasses
	}
	return nil
}

func (m *AttributeDefinition) GetDocumentation() string {
	if m != nil && m.Documentation != nil {
		return *m.Documentation
	}
	return ""
}

type RuleDefinition struct {
	Name *string `protobuf:"bytes,1,req,name=name" json:"name,omitempty"`
	// Only contains documented attributes
	Attribute     []*AttributeDefinition `protobuf:"bytes,2,rep,name=attribute" json:"attribute,omitempty"`
	Documentation *string                `protobuf:"bytes,3,opt,name=documentation" json:"documentation,omitempty"`
	// Only for build extensions: label to file that defines the extension
	Label            *string `protobuf:"bytes,4,opt,name=label" json:"label,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *RuleDefinition) Reset()                    { *m = RuleDefinition{} }
func (m *RuleDefinition) String() string            { return proto.CompactTextString(m) }
func (*RuleDefinition) ProtoMessage()               {}
func (*RuleDefinition) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{20} }

func (m *RuleDefinition) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *RuleDefinition) GetAttribute() []*AttributeDefinition {
	if m != nil {
		return m.Attribute
	}
	return nil
}

func (m *RuleDefinition) GetDocumentation() string {
	if m != nil && m.Documentation != nil {
		return *m.Documentation
	}
	return ""
}

func (m *RuleDefinition) GetLabel() string {
	if m != nil && m.Label != nil {
		return *m.Label
	}
	return ""
}

type BuildLanguage struct {
	// Only contains documented rule definitions
	Rule             []*RuleDefinition `protobuf:"bytes,1,rep,name=rule" json:"rule,omitempty"`
	XXX_unrecognized []byte            `json:"-"`
}

func (m *BuildLanguage) Reset()                    { *m = BuildLanguage{} }
func (m *BuildLanguage) String() string            { return proto.CompactTextString(m) }
func (*BuildLanguage) ProtoMessage()               {}
func (*BuildLanguage) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{21} }

func (m *BuildLanguage) GetRule() []*RuleDefinition {
	if m != nil {
		return m.Rule
	}
	return nil
}

type Location struct {
	StartOffset      *int32 `protobuf:"varint,1,opt,name=start_offset,json=startOffset" json:"start_offset,omitempty"`
	StartLine        *int32 `protobuf:"varint,2,opt,name=start_line,json=startLine" json:"start_line,omitempty"`
	StartColumn      *int32 `protobuf:"varint,3,opt,name=start_column,json=startColumn" json:"start_column,omitempty"`
	EndOffset        *int32 `protobuf:"varint,4,opt,name=end_offset,json=endOffset" json:"end_offset,omitempty"`
	EndLine          *int32 `protobuf:"varint,5,opt,name=end_line,json=endLine" json:"end_line,omitempty"`
	EndColumn        *int32 `protobuf:"varint,6,opt,name=end_column,json=endColumn" json:"end_column,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *Location) Reset()                    { *m = Location{} }
func (m *Location) String() string            { return proto.CompactTextString(m) }
func (*Location) ProtoMessage()               {}
func (*Location) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{22} }

func (m *Location) GetStartOffset() int32 {
	if m != nil && m.StartOffset != nil {
		return *m.StartOffset
	}
	return 0
}

func (m *Location) GetStartLine() int32 {
	if m != nil && m.StartLine != nil {
		return *m.StartLine
	}
	return 0
}

func (m *Location) GetStartColumn() int32 {
	if m != nil && m.StartColumn != nil {
		return *m.StartColumn
	}
	return 0
}

func (m *Location) GetEndOffset() int32 {
	if m != nil && m.EndOffset != nil {
		return *m.EndOffset
	}
	return 0
}

func (m *Location) GetEndLine() int32 {
	if m != nil && m.EndLine != nil {
		return *m.EndLine
	}
	return 0
}

func (m *Location) GetEndColumn() int32 {
	if m != nil && m.EndColumn != nil {
		return *m.EndColumn
	}
	return 0
}

type MakeVarBinding struct {
	Value             *string `protobuf:"bytes,1,req,name=value" json:"value,omitempty"`
	PlatformSetRegexp *string `protobuf:"bytes,2,req,name=platform_set_regexp,json=platformSetRegexp" json:"platform_set_regexp,omitempty"`
	XXX_unrecognized  []byte  `json:"-"`
}

func (m *MakeVarBinding) Reset()                    { *m = MakeVarBinding{} }
func (m *MakeVarBinding) String() string            { return proto.CompactTextString(m) }
func (*MakeVarBinding) ProtoMessage()               {}
func (*MakeVarBinding) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{23} }

func (m *MakeVarBinding) GetValue() string {
	if m != nil && m.Value != nil {
		return *m.Value
	}
	return ""
}

func (m *MakeVarBinding) GetPlatformSetRegexp() string {
	if m != nil && m.PlatformSetRegexp != nil {
		return *m.PlatformSetRegexp
	}
	return ""
}

type MakeVar struct {
	Name             *string           `protobuf:"bytes,1,req,name=name" json:"name,omitempty"`
	Binding          []*MakeVarBinding `protobuf:"bytes,2,rep,name=binding" json:"binding,omitempty"`
	XXX_unrecognized []byte            `json:"-"`
}

func (m *MakeVar) Reset()                    { *m = MakeVar{} }
func (m *MakeVar) String() string            { return proto.CompactTextString(m) }
func (*MakeVar) ProtoMessage()               {}
func (*MakeVar) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{24} }

func (m *MakeVar) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *MakeVar) GetBinding() []*MakeVarBinding {
	if m != nil {
		return m.Binding
	}
	return nil
}

type GlobCriteria struct {
	// List of includes (or items if this criteria did not come from a glob)
	Include []string `protobuf:"bytes,1,rep,name=include" json:"include,omitempty"`
	// List of exclude expressions
	Exclude []string `protobuf:"bytes,2,rep,name=exclude" json:"exclude,omitempty"`
	// Whether this message came from a glob
	Glob             *bool  `protobuf:"varint,3,opt,name=glob" json:"glob,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *GlobCriteria) Reset()                    { *m = GlobCriteria{} }
func (m *GlobCriteria) String() string            { return proto.CompactTextString(m) }
func (*GlobCriteria) ProtoMessage()               {}
func (*GlobCriteria) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{25} }

func (m *GlobCriteria) GetInclude() []string {
	if m != nil {
		return m.Include
	}
	return nil
}

func (m *GlobCriteria) GetExclude() []string {
	if m != nil {
		return m.Exclude
	}
	return nil
}

func (m *GlobCriteria) GetGlob() bool {
	if m != nil && m.Glob != nil {
		return *m.Glob
	}
	return false
}

type Event struct {
	Kind               *Event_EventKind `protobuf:"varint,1,req,name=kind,enum=blaze_query.Event_EventKind" json:"kind,omitempty"`
	DEPRECATEDLocation *Location        `protobuf:"bytes,2,opt,name=DEPRECATED_location,json=DEPRECATEDLocation" json:"DEPRECATED_location,omitempty"`
	Message            *string          `protobuf:"bytes,3,opt,name=message" json:"message,omitempty"`
	XXX_unrecognized   []byte           `json:"-"`
}

func (m *Event) Reset()                    { *m = Event{} }
func (m *Event) String() string            { return proto.CompactTextString(m) }
func (*Event) ProtoMessage()               {}
func (*Event) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{26} }

func (m *Event) GetKind() Event_EventKind {
	if m != nil && m.Kind != nil {
		return *m.Kind
	}
	return Event_ERROR
}

func (m *Event) GetDEPRECATEDLocation() *Location {
	if m != nil {
		return m.DEPRECATEDLocation
	}
	return nil
}

func (m *Event) GetMessage() string {
	if m != nil && m.Message != nil {
		return *m.Message
	}
	return ""
}

func init() {
	proto.RegisterType((*License)(nil), "blaze_query.License")
	proto.RegisterType((*StringDictEntry)(nil), "blaze_query.StringDictEntry")
	proto.RegisterType((*LabelDictUnaryEntry)(nil), "blaze_query.LabelDictUnaryEntry")
	proto.RegisterType((*LabelListDictEntry)(nil), "blaze_query.LabelListDictEntry")
	proto.RegisterType((*LabelKeyedStringDictEntry)(nil), "blaze_query.LabelKeyedStringDictEntry")
	proto.RegisterType((*StringListDictEntry)(nil), "blaze_query.StringListDictEntry")
	proto.RegisterType((*FilesetEntry)(nil), "blaze_query.FilesetEntry")
	proto.RegisterType((*Attribute)(nil), "blaze_query.Attribute")
	proto.RegisterType((*Attribute_SelectorEntry)(nil), "blaze_query.Attribute.SelectorEntry")
	proto.RegisterType((*Attribute_Selector)(nil), "blaze_query.Attribute.Selector")
	proto.RegisterType((*Attribute_SelectorList)(nil), "blaze_query.Attribute.SelectorList")
	proto.RegisterType((*Rule)(nil), "blaze_query.Rule")
	proto.RegisterType((*AttributeAspect)(nil), "blaze_query.AttributeAspect")
	proto.RegisterType((*SkylarkAspect)(nil), "blaze_query.SkylarkAspect")
	proto.RegisterType((*RuleSummary)(nil), "blaze_query.RuleSummary")
	proto.RegisterType((*PackageGroup)(nil), "blaze_query.PackageGroup")
	proto.RegisterType((*EnvironmentGroup)(nil), "blaze_query.EnvironmentGroup")
	proto.RegisterType((*SourceFile)(nil), "blaze_query.SourceFile")
	proto.RegisterType((*GeneratedFile)(nil), "blaze_query.GeneratedFile")
	proto.RegisterType((*Target)(nil), "blaze_query.Target")
	proto.RegisterType((*QueryResult)(nil), "blaze_query.QueryResult")
	proto.RegisterType((*AllowedRuleClassInfo)(nil), "blaze_query.AllowedRuleClassInfo")
	proto.RegisterType((*AttributeDefinition)(nil), "blaze_query.AttributeDefinition")
	proto.RegisterType((*RuleDefinition)(nil), "blaze_query.RuleDefinition")
	proto.RegisterType((*BuildLanguage)(nil), "blaze_query.BuildLanguage")
	proto.RegisterType((*Location)(nil), "blaze_query.Location")
	proto.RegisterType((*MakeVarBinding)(nil), "blaze_query.MakeVarBinding")
	proto.RegisterType((*MakeVar)(nil), "blaze_query.MakeVar")
	proto.RegisterType((*GlobCriteria)(nil), "blaze_query.GlobCriteria")
	proto.RegisterType((*Event)(nil), "blaze_query.Event")
	proto.RegisterEnum("blaze_query.FilesetEntry_SymlinkBehavior", FilesetEntry_SymlinkBehavior_name, FilesetEntry_SymlinkBehavior_value)
	proto.RegisterEnum("blaze_query.Attribute_Discriminator", Attribute_Discriminator_name, Attribute_Discriminator_value)
	proto.RegisterEnum("blaze_query.Attribute_Tristate", Attribute_Tristate_name, Attribute_Tristate_value)
	proto.RegisterEnum("blaze_query.Target_Discriminator", Target_Discriminator_name, Target_Discriminator_value)
	proto.RegisterEnum("blaze_query.AllowedRuleClassInfo_AllowedRuleClasses", AllowedRuleClassInfo_AllowedRuleClasses_name, AllowedRuleClassInfo_AllowedRuleClasses_value)
	proto.RegisterEnum("blaze_query.Event_EventKind", Event_EventKind_name, Event_EventKind_value)
}

func init() {
	proto.RegisterFile("third_party/bazel/master/src/main/protobuf/build.proto", fileDescriptor0)
}

var fileDescriptor0 = []byte{
	// 2649 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xec, 0x59, 0x4b, 0x73, 0xe3, 0xc6,
	0x11, 0x0e, 0xf8, 0x10, 0xc9, 0xe6, 0x0b, 0x1a, 0x3d, 0x96, 0xfb, 0xb2, 0x69, 0x78, 0x1d, 0xcb,
	0x8f, 0x92, 0x6c, 0x65, 0xed, 0x72, 0xec, 0x64, 0x2b, 0x14, 0x05, 0xc9, 0xf4, 0xd2, 0xa4, 0x32,
	0xa4, 0xd6, 0x51, 0x2e, 0x28, 0x10, 0x18, 0x51, 0x53, 0x02, 0x01, 0x06, 0x03, 0x6e, 0x96, 0xbe,
	0xa6, 0x72, 0x70, 0x7e, 0x83, 0x0f, 0xf9, 0x17, 0xb9, 0xe6, 0x98, 0x9f, 0x90, 0x54, 0x2e, 0x39,
	0xe6, 0x47, 0xe4, 0x90, 0x9a, 0x07, 0x48, 0x40, 0xa2, 0xbc, 0xf2, 0x3a, 0xb9, 0xa4, 0x72, 0x61,
	0x71, 0xfa, 0xf1, 0x4d, 0xf7, 0x4c, 0x77, 0x4f, 0xcf, 0x00, 0x3e, 0x8e, 0x2e, 0x68, 0xe8, 0x5a,
	0x53, 0x3b, 0x8c, 0xe6, 0x7b, 0x23, 0xfb, 0x6b, 0xe2, 0xed, 0x4d, 0x6c, 0x16, 0x91, 0x70, 0x8f,
	0x85, 0xce, 0xde, 0xc4, 0xa6, 0xfe, 0xde, 0x34, 0x0c, 0xa2, 0x60, 0x34, 0x3b, 0xdf, 0x1b, 0xcd,
	0xa8, 0xe7, 0xee, 0x8a, 0x21, 0x2a, 0x8f, 0x3c, 0xfb, 0x6b, 0x62, 0xfd, 0x66, 0x46, 0xc2, 0xb9,
	0xf1, 0x05, 0x14, 0xba, 0xd4, 0x21, 0x3e, 0x23, 0xe8, 0x0d, 0xa8, 0x78, 0xf2, 0xaf, 0x15, 0xcd,
	0xa7, 0xa4, 0xa1, 0x35, 0xb3, 0x3b, 0x25, 0x5c, 0x56, 0xb4, 0xe1, 0x7c, 0x4a, 0xd0, 0x03, 0x28,
	0x91, 0x17, 0x0e, 0x99, 0x46, 0x34, 0xf0, 0x1b, 0x19, 0xc1, 0x5f, 0x12, 0x8c, 0x9f, 0x42, 0x7d,
	0x10, 0x85, 0xd4, 0x1f, 0x1f, 0x52, 0x27, 0x32, 0xfd, 0x28, 0x9c, 0x23, 0x1d, 0xb2, 0x97, 0x64,
	0xde, 0xd0, 0x9a, 0x99, 0x9d, 0x12, 0xe6, 0x7f, 0xd1, 0x26, 0xe4, 0x9f, 0xdb, 0xde, 0x8c, 0x34,
	0x32, 0x82, 0x26, 0x07, 0xc6, 0xcf, 0x61, 0xa3, 0x6b, 0x8f, 0x88, 0xc7, 0x35, 0x4f, 0x7d, 0x3b,
	0x9c, 0x7f, 0x3f, 0xf5, 0x9f, 0x01, 0x12, 0xea, 0x5d, 0xca, 0xa2, 0x5b, 0x4e, 0x9e, 0x5d, 0x6a,
	0xb7, 0xe1, 0xae, 0xd0, 0x7e, 0x4a, 0xe6, 0xc4, 0xfd, 0x01, 0x1e, 0x48, 0xd5, 0x57, 0xb3, 0xe1,
	0xef, 0x19, 0xa8, 0x1c, 0x51, 0x8f, 0x30, 0xa2, 0x14, 0xb7, 0x61, 0x8d, 0x05, 0xb3, 0xd0, 0x21,
	0x4a, 0x57, 0x8d, 0xd0, 0x4f, 0x60, 0xcb, 0x25, 0x2c, 0xa2, 0xbe, 0xcd, 0xd7, 0xdc, 0x72, 0x69,
	0x48, 0x9c, 0x28, 0x08, 0xe7, 0xca, 0x9a, 0xcd, 0x04, 0xf3, 0x30, 0xe6, 0xa1, 0x37, 0xa1, 0x7a,
	0xce, 0xc1, 0xad, 0x69, 0x48, 0x18, 0xf1, 0xa3, 0x46, 0xa1, 0xa9, 0xed, 0x14, 0x71, 0x45, 0x10,
	0x4f, 0x24, 0x0d, 0x21, 0xc8, 0xf1, 0x71, 0x23, 0x2b, 0xec, 0x12, 0xff, 0x51, 0x03, 0x0a, 0xe4,
	0x85, 0xe3, 0xcd, 0x5c, 0xd2, 0xc8, 0x09, 0x72, 0x3c, 0x44, 0xbf, 0x06, 0x9d, 0xcd, 0x27, 0x1e,
	0xf5, 0x2f, 0xad, 0x11, 0xb9, 0xb0, 0x9f, 0xd3, 0x20, 0x6c, 0xe4, 0x9b, 0xda, 0x4e, 0x6d, 0xff,
	0x9d, 0xdd, 0x44, 0x80, 0xed, 0x26, 0x9d, 0xda, 0x1d, 0x48, 0x8d, 0x03, 0xa5, 0xf0, 0x69, 0xae,
	0xdd, 0x3f, 0x39, 0xc3, 0x75, 0x96, 0x26, 0xf3, 0x48, 0x64, 0x51, 0x48, 0xa7, 0xdc, 0xdc, 0x73,
	0xfa, 0xa2, 0xb1, 0xd6, 0xd4, 0x78, 0x24, 0x0a, 0xda, 0x89, 0x20, 0x19, 0xef, 0x43, 0xfd, 0x0a,
	0x18, 0x2a, 0x82, 0x80, 0xd3, 0x35, 0x54, 0x87, 0xf2, 0xa1, 0x89, 0xcd, 0x23, 0x13, 0x9b, 0xbd,
	0xb6, 0xa9, 0x67, 0x8c, 0x7f, 0xde, 0x81, 0x52, 0x2b, 0x8a, 0x42, 0x3a, 0x9a, 0x45, 0x84, 0x3b,
	0xea, 0xdb, 0x93, 0x78, 0x61, 0xc5, 0x7f, 0x74, 0x06, 0x0f, 0x0f, 0xcd, 0x13, 0x6c, 0xb6, 0x5b,
	0x43, 0xf3, 0x90, 0xe7, 0x14, 0x23, 0xf6, 0xc8, 0x23, 0x96, 0x17, 0x38, 0x62, 0x2d, 0x1b, 0x95,
	0xa6, 0xb6, 0x53, 0xde, 0xdf, 0x4a, 0xf9, 0xd6, 0x55, 0x4c, 0x7c, 0x7f, 0xa9, 0x7b, 0x12, 0xab,
	0xc6, 0x4c, 0xf4, 0x21, 0x6c, 0x92, 0x17, 0x53, 0x8f, 0x3a, 0x34, 0xf2, 0xe6, 0x16, 0x9b, 0x12,
	0x87, 0x9e, 0x53, 0xe2, 0x36, 0xaa, 0x62, 0x0f, 0x36, 0x96, 0xbc, 0x41, 0xcc, 0xe2, 0x31, 0xe2,
	0x07, 0x2e, 0x99, 0x36, 0x36, 0x85, 0x8c, 0x1c, 0xa0, 0x4f, 0x20, 0x27, 0x12, 0x93, 0xef, 0x74,
	0x6d, 0xff, 0x51, 0xca, 0x94, 0x85, 0x77, 0xbb, 0x87, 0x94, 0x39, 0x21, 0x9d, 0xf0, 0x18, 0x08,
	0x42, 0x2c, 0x34, 0xd0, 0x7d, 0x28, 0x51, 0x3f, 0xb2, 0x64, 0xdc, 0x65, 0x9b, 0xda, 0x4e, 0x1e,
	0x17, 0xa9, 0x1f, 0x3d, 0xe3, 0xe3, 0x78, 0xb5, 0xfd, 0xb1, 0xe2, 0xe7, 0x97, 0xab, 0xed, 0x8f,
	0xa5, 0xc8, 0x9b, 0x50, 0x1d, 0x05, 0x81, 0x47, 0x6c, 0x5f, 0xc9, 0xd4, 0x64, 0xfc, 0x28, 0xa2,
	0x14, 0x3a, 0x82, 0x5a, 0x14, 0x52, 0x16, 0xd9, 0x11, 0x51, 0x52, 0x75, 0x11, 0x0f, 0xaf, 0xdf,
	0x60, 0xe8, 0x50, 0x09, 0xe3, 0x6a, 0xac, 0x26, 0x71, 0xde, 0x85, 0x75, 0x65, 0x8f, 0x47, 0x59,
	0x6c, 0xf4, 0x9a, 0x88, 0xbe, 0x3a, 0x5b, 0xa4, 0x98, 0x94, 0xdd, 0x85, 0x82, 0xaa, 0x4f, 0x22,
	0xa4, 0xcb, 0xfb, 0x9b, 0xe9, 0x0d, 0x92, 0x3c, 0x1c, 0x0b, 0xa1, 0xcf, 0x17, 0xd8, 0x2e, 0x75,
	0x62, 0xec, 0x62, 0x33, 0xbb, 0x53, 0xde, 0x7f, 0x90, 0xd2, 0xbc, 0x52, 0x06, 0xe2, 0x99, 0x39,
	0x41, 0xce, 0x7c, 0x0c, 0xe8, 0x5c, 0x86, 0x76, 0xd2, 0xcc, 0x92, 0x80, 0xba, 0x7b, 0x63, 0x06,
	0x60, 0x5d, 0x29, 0x2d, 0x5d, 0xc0, 0xb0, 0xe5, 0xf1, 0xea, 0x23, 0x61, 0x12, 0x66, 0x81, 0xc0,
	0x4a, 0xaf, 0xde, 0xf5, 0x2a, 0x87, 0x91, 0x97, 0xa4, 0x49, 0xcc, 0x53, 0xd8, 0x4e, 0x2e, 0x61,
	0x02, 0xb4, 0x2c, 0x40, 0x9b, 0x2b, 0x7c, 0x4d, 0xa3, 0x6e, 0xb0, 0x14, 0x51, 0xc2, 0x3e, 0x81,
	0xea, 0xd8, 0x0b, 0x46, 0x96, 0x13, 0xd2, 0x88, 0x84, 0xd4, 0x6e, 0xe8, 0x2b, 0xdc, 0x3d, 0xf6,
	0x82, 0x51, 0x5b, 0x09, 0xe0, 0xca, 0x38, 0x31, 0x42, 0x8f, 0xa0, 0xc6, 0xc3, 0x30, 0xb1, 0x5e,
	0xeb, 0xcd, 0xec, 0x4e, 0x1e, 0x57, 0xa8, 0x9f, 0x58, 0x90, 0x53, 0xd8, 0x96, 0x0b, 0x22, 0xcc,
	0x9e, 0xf1, 0xd3, 0x40, 0x49, 0x6f, 0xac, 0x30, 0x7e, 0xc5, 0xb1, 0x81, 0x37, 0xbc, 0x14, 0x51,
	0xc2, 0x5e, 0xc0, 0x43, 0x09, 0x7b, 0xc9, 0xcb, 0xbc, 0x75, 0x3d, 0x0c, 0xb6, 0x05, 0xfa, 0x8f,
	0xaf, 0xa3, 0xaf, 0x3a, 0x17, 0xf0, 0x5d, 0x6f, 0x05, 0x4b, 0xce, 0xf4, 0x39, 0x54, 0x19, 0xf1,
	0x44, 0xe9, 0x15, 0xbe, 0x36, 0xb6, 0x44, 0x68, 0xbe, 0x79, 0x43, 0x1e, 0x0c, 0x94, 0x2c, 0x5f,
	0x01, 0x5c, 0x61, 0x89, 0x11, 0xfa, 0x02, 0x8c, 0x44, 0x55, 0x4a, 0x9a, 0x9c, 0x5c, 0x16, 0xd4,
	0xcc, 0xee, 0x54, 0xf0, 0x6b, 0x4b, 0xc9, 0xa5, 0x41, 0x4b, 0xff, 0xef, 0x7d, 0x53, 0x84, 0x6a,
	0x3c, 0x95, 0x3c, 0x62, 0x36, 0x21, 0x2f, 0x9c, 0x68, 0x68, 0x22, 0xe3, 0xe5, 0x00, 0xed, 0x80,
	0x4e, 0x99, 0xe5, 0x92, 0x73, 0x7b, 0xe6, 0xc5, 0x4b, 0xa3, 0x8b, 0x74, 0xaf, 0x51, 0x76, 0x28,
	0xc9, 0xd2, 0xcf, 0x54, 0x55, 0xc9, 0xbc, 0xa4, 0xaa, 0x64, 0x6f, 0x51, 0x55, 0x72, 0xb7, 0xaa,
	0x2a, 0xf9, 0xff, 0x57, 0x95, 0xff, 0xed, 0xaa, 0x52, 0xf9, 0xa1, 0x55, 0xa5, 0xfa, 0xbd, 0xaa,
	0x4a, 0xfd, 0xbf, 0x5a, 0x55, 0xd6, 0xff, 0x53, 0x55, 0xe5, 0x76, 0xb5, 0xa0, 0x76, 0xab, 0x5a,
	0xf0, 0xad, 0x06, 0xc5, 0xb8, 0x16, 0xa0, 0x27, 0x50, 0x20, 0x7e, 0x14, 0x52, 0xc2, 0x44, 0xcb,
	0x5f, 0xbe, 0xb1, 0xb3, 0x48, 0x55, 0x0f, 0x1c, 0x2b, 0xf1, 0xcc, 0xba, 0xb0, 0xaf, 0x56, 0x8c,
	0x8c, 0x48, 0xe5, 0xfa, 0x85, 0x9d, 0x2e, 0x19, 0x8f, 0xa0, 0xe6, 0x07, 0xd6, 0xc4, 0x8e, 0x9c,
	0x0b, 0x8b, 0x84, 0x61, 0x10, 0xaa, 0xba, 0x50, 0xf1, 0x83, 0x2f, 0x39, 0xd1, 0xe4, 0xb4, 0x7b,
	0xbf, 0xd7, 0xa0, 0x92, 0xac, 0x8a, 0x8b, 0xce, 0x47, 0x13, 0xa9, 0xff, 0x7d, 0x3a, 0x9f, 0xcf,
	0xa0, 0x48, 0x3c, 0x32, 0x21, 0x7e, 0xc4, 0x44, 0xc3, 0x5d, 0xbe, 0xb1, 0x70, 0xc4, 0x13, 0xe2,
	0x85, 0x82, 0xf1, 0x87, 0x2c, 0x54, 0x53, 0xa0, 0xa8, 0x0c, 0x85, 0x4e, 0x6f, 0x68, 0x1e, 0x9b,
	0x58, 0xd7, 0x10, 0xc0, 0xda, 0x60, 0x88, 0x3b, 0xbd, 0x63, 0x3d, 0x83, 0x4a, 0x90, 0xef, 0xb6,
	0x0e, 0xcc, 0xae, 0x9e, 0xe5, 0xe4, 0xfe, 0xe9, 0xf0, 0xe4, 0x74, 0xa8, 0xe7, 0x78, 0x27, 0x2a,
	0x45, 0xac, 0x6e, 0x67, 0x30, 0xd4, 0xf3, 0xa8, 0x06, 0x20, 0xe4, 0xe4, 0x78, 0x8d, 0x0b, 0x48,
	0x61, 0x49, 0x28, 0xa0, 0x4d, 0xd0, 0x0f, 0x3b, 0x5c, 0xe7, 0xe0, 0x74, 0xd8, 0xe9, 0xf7, 0xac,
	0x81, 0x39, 0xd4, 0x8b, 0x7c, 0xde, 0x6e, 0xa7, 0x6d, 0xf6, 0x06, 0xa6, 0x5e, 0x4a, 0x80, 0x1e,
	0x76, 0xda, 0x43, 0x1d, 0xd0, 0x36, 0xa0, 0xa3, 0x4e, 0xd7, 0x1c, 0x98, 0x43, 0xcb, 0xec, 0x0d,
	0xf1, 0x99, 0xc4, 0x2a, 0xa3, 0x0d, 0xa8, 0x2f, 0x27, 0x93, 0xc2, 0x15, 0x3e, 0x41, 0xc2, 0x24,
	0x49, 0xad, 0xf2, 0x09, 0x0e, 0xfa, 0xfd, 0xae, 0xd9, 0xea, 0xe9, 0x35, 0x54, 0x81, 0xe2, 0x10,
	0x77, 0x06, 0xc3, 0xd6, 0xd0, 0xd4, 0xeb, 0x48, 0x87, 0x8a, 0xf2, 0x59, 0xe2, 0xea, 0x5c, 0xf8,
	0xb4, 0xf7, 0xb4, 0xd7, 0xff, 0xaa, 0xa7, 0x23, 0x8e, 0x27, 0x27, 0xe1, 0x48, 0xd6, 0x69, 0xaf,
	0x85, 0xcf, 0xf4, 0x0d, 0xb4, 0x0e, 0xd5, 0x81, 0xd9, 0x35, 0xdb, 0xc3, 0xbe, 0xd2, 0xda, 0x44,
	0xf7, 0xe1, 0x8e, 0x14, 0x7c, 0x6a, 0x9e, 0x99, 0x87, 0x56, 0xd2, 0x85, 0x2d, 0xd4, 0x84, 0x07,
	0x89, 0xe8, 0x4e, 0xf0, 0x14, 0xe2, 0xba, 0xf1, 0x16, 0x14, 0xe3, 0xda, 0x8e, 0xd6, 0x20, 0xd3,
	0xeb, 0xeb, 0x3f, 0x42, 0x05, 0xc8, 0x9e, 0x99, 0x03, 0x5d, 0xe3, 0xbd, 0x7f, 0xeb, 0x74, 0xd8,
	0xd7, 0x33, 0xc6, 0x9f, 0x72, 0x90, 0xc3, 0x33, 0x6f, 0x75, 0x97, 0xff, 0x10, 0x20, 0x9c, 0x79,
	0xc4, 0x72, 0x3c, 0x9b, 0x31, 0x75, 0x63, 0x2a, 0x71, 0x4a, 0x9b, 0x13, 0xd0, 0x3d, 0x28, 0x2e,
	0xfa, 0x7d, 0x19, 0x97, 0x8b, 0x31, 0x7a, 0x0c, 0x25, 0x3b, 0x8e, 0x15, 0x71, 0x17, 0x2a, 0xef,
	0x6f, 0xaf, 0x8e, 0x24, 0xbc, 0x14, 0x5c, 0x4c, 0x48, 0xfd, 0xe9, 0x2c, 0x6a, 0xe4, 0xe5, 0x8d,
	0x99, 0x53, 0x3a, 0x9c, 0x80, 0x5e, 0x87, 0xb2, 0x60, 0x07, 0xb3, 0x88, 0xf3, 0xe5, 0x71, 0x24,
	0x34, 0xfa, 0x82, 0x82, 0xde, 0x86, 0x7a, 0x9c, 0x57, 0x8c, 0x44, 0x11, 0xf5, 0xc7, 0x8d, 0x82,
	0x10, 0xaa, 0x29, 0xf2, 0x40, 0x52, 0x5f, 0x7e, 0x7f, 0x29, 0xbe, 0xf2, 0xfd, 0xe5, 0x5d, 0x58,
	0x9f, 0xce, 0x46, 0x1e, 0x75, 0xac, 0xd1, 0x3c, 0xce, 0xf2, 0x46, 0x49, 0xe6, 0xb7, 0x64, 0x1c,
	0xcc, 0x55, 0x92, 0x73, 0x7f, 0x29, 0xb3, 0xd8, 0xe5, 0xdc, 0xb3, 0xc3, 0xcb, 0x06, 0x08, 0xa1,
	0x12, 0x65, 0x03, 0x49, 0x40, 0xbf, 0x82, 0xbb, 0x8a, 0x67, 0x2d, 0xd6, 0xc8, 0xb2, 0xf9, 0x95,
	0x28, 0x62, 0xea, 0x10, 0x79, 0xb0, 0x7a, 0x51, 0x5b, 0x42, 0x08, 0xdf, 0x51, 0xea, 0x57, 0xe8,
	0x0c, 0xb5, 0xe0, 0x61, 0x8c, 0x4c, 0xfc, 0xe7, 0x34, 0x0c, 0x7c, 0x9e, 0xc2, 0xd6, 0x85, 0xcd,
	0x2e, 0x2c, 0x27, 0x70, 0x89, 0xb8, 0xbf, 0x95, 0xf0, 0x3d, 0x25, 0x64, 0x2e, 0x65, 0x3e, 0xb7,
	0xd9, 0x45, 0x3b, 0x70, 0x89, 0xe1, 0x41, 0xfd, 0x0a, 0x2c, 0x7a, 0x0b, 0x6a, 0x4b, 0x3b, 0x13,
	0xd1, 0x54, 0x5d, 0x50, 0x7b, 0x3c, 0xac, 0xf6, 0x61, 0x4d, 0x3a, 0x21, 0x42, 0xaa, 0xbc, 0x7f,
	0x2f, 0x7d, 0x10, 0x2a, 0x93, 0xa5, 0x07, 0x4a, 0xd2, 0xf8, 0x56, 0x83, 0x6a, 0x8a, 0x83, 0x3e,
	0xe0, 0xf7, 0xc4, 0x88, 0xf8, 0x8c, 0xdf, 0xeb, 0xf9, 0x81, 0x6e, 0xc5, 0xdd, 0x19, 0x9f, 0x12,
	0x2d, 0x78, 0xfc, 0xe4, 0x17, 0x27, 0x08, 0x6f, 0xa0, 0xc8, 0x8b, 0x69, 0x10, 0x46, 0xc4, 0x95,
	0xd6, 0xc9, 0x88, 0xae, 0xc4, 0x44, 0x61, 0x5c, 0x2a, 0x70, 0xb3, 0xb7, 0x0c, 0x5c, 0xe3, 0x77,
	0x1a, 0x94, 0x79, 0x1a, 0x0d, 0x66, 0x93, 0x89, 0x1d, 0xce, 0xd1, 0x5b, 0x90, 0xe3, 0x61, 0x29,
	0x8c, 0x29, 0xef, 0xaf, 0xa7, 0x00, 0xb8, 0x1c, 0x16, 0x6c, 0xf4, 0x21, 0x80, 0x4b, 0xa6, 0xc4,
	0x77, 0x89, 0xef, 0xcc, 0x55, 0xc1, 0x5d, 0x21, 0x9c, 0x10, 0xfa, 0xae, 0xa4, 0x33, 0xfe, 0xa1,
	0x41, 0xe5, 0xc4, 0x76, 0x2e, 0xed, 0x31, 0x39, 0x0e, 0x83, 0xd9, 0x74, 0x65, 0x52, 0xbf, 0x07,
	0xeb, 0x4e, 0xe0, 0x47, 0x36, 0xf5, 0x89, 0x6b, 0x4d, 0xa5, 0xb4, 0x7a, 0x5c, 0xd1, 0x17, 0x0c,
	0x85, 0x82, 0x1e, 0xc3, 0x36, 0xf5, 0xc5, 0x0b, 0xc6, 0x42, 0xd6, 0x1a, 0x73, 0x68, 0xf5, 0xec,
	0xb1, 0x19, 0x73, 0x53, 0xd3, 0xbe, 0x34, 0xbb, 0x72, 0xaf, 0x9a, 0x5d, 0xc6, 0x08, 0xf4, 0x44,
	0x30, 0xde, 0xec, 0x65, 0x13, 0xca, 0x89, 0xc0, 0x56, 0xfe, 0x25, 0x49, 0xa8, 0x01, 0x85, 0x38,
	0x3b, 0xa5, 0x2f, 0xf1, 0xd0, 0xf8, 0x26, 0x0b, 0x30, 0x10, 0xcf, 0x47, 0x3c, 0x76, 0x56, 0xc2,
	0x27, 0x77, 0x21, 0x73, 0xa5, 0xf4, 0xbd, 0xd4, 0xfb, 0xc2, 0x2b, 0xd7, 0x96, 0xd7, 0x00, 0xd8,
	0x6c, 0xa4, 0xd6, 0x5c, 0x99, 0x9d, 0xa0, 0xf0, 0x08, 0x4f, 0xef, 0x92, 0x7c, 0x85, 0xaa, 0x4c,
	0x93, 0xbb, 0xf3, 0x0e, 0xe8, 0xcf, 0x29, 0xa3, 0x23, 0xea, 0xd1, 0x68, 0xae, 0x92, 0x46, 0x96,
	0xda, 0xfa, 0x92, 0x2e, 0x33, 0xa6, 0x01, 0x85, 0x73, 0x62, 0x47, 0xb3, 0x30, 0xee, 0xfd, 0xe3,
	0x61, 0xb2, 0xe7, 0x2f, 0xde, 0xa6, 0xe7, 0xff, 0x18, 0xee, 0xc4, 0x96, 0xa9, 0x20, 0x63, 0xb2,
	0xa3, 0x61, 0xaa, 0x36, 0x6e, 0x29, 0x76, 0x5b, 0x71, 0x45, 0x6b, 0xc3, 0x8c, 0x0b, 0xa8, 0x1e,
	0x13, 0x9f, 0x84, 0x76, 0x44, 0xdc, 0x1b, 0x77, 0xe3, 0x6d, 0xa8, 0x8f, 0xa5, 0x10, 0x6f, 0xf2,
	0x44, 0xe2, 0xc9, 0xd4, 0xae, 0x2d, 0xc9, 0xe2, 0x90, 0xfb, 0xae, 0xe4, 0xf9, 0x5b, 0x16, 0xd6,
	0x86, 0x76, 0x38, 0x26, 0x11, 0xfa, 0x68, 0xd1, 0x3f, 0x65, 0x76, 0x6a, 0xfb, 0x6f, 0xa4, 0x3c,
	0x93, 0x22, 0x2b, 0x9b, 0xa7, 0x38, 0xe9, 0x33, 0x62, 0x41, 0x6e, 0x4c, 0xfa, 0x4f, 0xa0, 0x2c,
	0x1f, 0x27, 0x2d, 0xf5, 0x7e, 0xc8, 0xa5, 0xef, 0xa4, 0x6b, 0xe0, 0x22, 0xfa, 0x30, 0xb0, 0x65,
	0x24, 0xb6, 0x20, 0x76, 0x88, 0xb8, 0x52, 0x59, 0x26, 0x52, 0xba, 0x80, 0xa6, 0xd6, 0x0b, 0x57,
	0xc7, 0xa9, 0xe5, 0x7b, 0x72, 0x35, 0x42, 0xf2, 0x02, 0x21, 0x7d, 0x7b, 0x48, 0x26, 0xf3, 0x95,
	0xe0, 0xf9, 0x02, 0xd6, 0x93, 0x07, 0x86, 0xc4, 0x58, 0x13, 0x18, 0x0f, 0x53, 0x18, 0x57, 0xb3,
	0x14, 0xeb, 0xe4, 0x0a, 0x85, 0xef, 0x6d, 0xba, 0x5d, 0x2c, 0x42, 0x0e, 0x9f, 0x76, 0x4d, 0xf9,
	0x24, 0x39, 0xe8, 0x9f, 0xe2, 0xb6, 0x69, 0xf1, 0x4e, 0x4d, 0xcf, 0x20, 0x04, 0xb5, 0x63, 0xb3,
	0x67, 0x62, 0x91, 0x53, 0x82, 0x96, 0xe5, 0x4d, 0xd3, 0x49, 0xab, 0xfd, 0xb4, 0x75, 0x6c, 0x5a,
	0xc7, 0xb8, 0x7f, 0x7a, 0xa2, 0xe7, 0xd0, 0x16, 0xac, 0x9b, 0xbd, 0x67, 0x1d, 0xdc, 0xef, 0x7d,
	0x69, 0xf6, 0x86, 0x8a, 0x9c, 0x37, 0x3e, 0x85, 0xf2, 0x2f, 0xb9, 0x55, 0x98, 0x30, 0x7e, 0xec,
	0xbe, 0x07, 0x6b, 0x91, 0xd8, 0x46, 0xd5, 0xc1, 0x6f, 0xac, 0xd8, 0x61, 0xac, 0x44, 0x8c, 0x3f,
	0x6b, 0xb0, 0xd9, 0xf2, 0xbc, 0xe0, 0xb7, 0xc4, 0xc5, 0x71, 0xeb, 0xd3, 0xf1, 0xcf, 0x03, 0xd4,
	0x85, 0xb5, 0x69, 0xe0, 0x51, 0x67, 0xae, 0xe2, 0xe4, 0x71, 0xfa, 0x98, 0x58, 0xa1, 0x72, 0x8d,
	0x48, 0x18, 0x56, 0x18, 0xe8, 0x7d, 0x40, 0xb6, 0xe4, 0x5a, 0xa9, 0x9e, 0x4b, 0xd4, 0x65, 0xfb,
	0x8a, 0x9e, 0xf1, 0x3e, 0xa0, 0xeb, 0x58, 0xbc, 0xbf, 0x6b, 0xf5, 0xce, 0x74, 0x0d, 0x55, 0xa1,
	0x34, 0x38, 0x31, 0xdb, 0x9d, 0xa3, 0x8e, 0x79, 0xa8, 0x67, 0x8c, 0x7f, 0x69, 0xb0, 0xb1, 0x38,
	0xb6, 0x0e, 0xc9, 0x39, 0xf5, 0xa9, 0x28, 0x27, 0xab, 0x72, 0xe9, 0xd5, 0x5f, 0x4d, 0x1f, 0x40,
	0x69, 0x62, 0xfb, 0xae, 0x2d, 0x9e, 0xd7, 0xb3, 0xcd, 0x0c, 0xef, 0x65, 0x16, 0x04, 0x34, 0x80,
	0xcd, 0xeb, 0xfe, 0x11, 0xa6, 0x22, 0xf8, 0x8d, 0x97, 0xae, 0x1d, 0x46, 0xf6, 0x75, 0x87, 0x1f,
	0x41, 0xd5, 0x0d, 0x9c, 0x19, 0x0f, 0x29, 0x99, 0xd4, 0xf2, 0x31, 0x36, 0x4d, 0x34, 0xfe, 0xa8,
	0x41, 0x8d, 0x6b, 0xbd, 0xc4, 0xf3, 0x27, 0xc9, 0x93, 0x3f, 0xb3, 0xe2, 0x96, 0xbb, 0x62, 0x09,
	0x93, 0xcd, 0xeb, 0x35, 0x63, 0xb2, 0x2b, 0x8c, 0x59, 0xbe, 0x22, 0xe5, 0x12, 0xaf, 0x48, 0xc6,
	0x2f, 0xa0, 0x7a, 0x30, 0xa3, 0x9e, 0xdb, 0xb5, 0xfd, 0xf1, 0x8c, 0x1f, 0xbc, 0x7b, 0x8b, 0x06,
	0x82, 0xdb, 0x71, 0xff, 0x5a, 0x2d, 0x49, 0x98, 0x20, 0x04, 0x8d, 0xbf, 0x68, 0x50, 0x5c, 0x9c,
	0x13, 0xe2, 0x35, 0xc9, 0x0e, 0x23, 0x2b, 0x38, 0x3f, 0x67, 0x22, 0xcc, 0xb5, 0x9d, 0x3c, 0x2e,
	0x0b, 0x5a, 0x5f, 0x90, 0x78, 0xeb, 0x29, 0x45, 0x3c, 0xea, 0xc7, 0xcf, 0x51, 0x25, 0x41, 0xe9,
	0x52, 0x9f, 0x2c, 0x11, 0x9c, 0xc0, 0x9b, 0x4d, 0x7c, 0xf5, 0x0a, 0x2e, 0x11, 0xda, 0x82, 0xc4,
	0x11, 0x88, 0xef, 0xc6, 0x53, 0xe4, 0x24, 0x02, 0xf1, 0x5d, 0x35, 0xc1, 0x5d, 0x28, 0x72, 0xb6,
	0x80, 0xcf, 0x0b, 0x66, 0x81, 0xf8, 0xae, 0x00, 0x57, 0x9a, 0x0a, 0x7a, 0x6d, 0xa1, 0x29, 0x81,
	0x8d, 0x67, 0x50, 0xfb, 0xd2, 0xbe, 0x24, 0xcf, 0xec, 0xf0, 0x80, 0xfa, 0x2e, 0x6f, 0xd7, 0x17,
	0x1f, 0x81, 0xb4, 0xc4, 0x37, 0x24, 0xb4, 0x0b, 0x1b, 0x53, 0xcf, 0x8e, 0xce, 0x83, 0x70, 0xc2,
	0xdb, 0x7d, 0x2b, 0x24, 0x63, 0xf2, 0x62, 0xaa, 0x4a, 0xff, 0x7a, 0xcc, 0x1a, 0x90, 0x08, 0x0b,
	0x86, 0x31, 0x84, 0x82, 0xc2, 0x5d, 0xb9, 0xff, 0x1f, 0x41, 0x61, 0x24, 0xe7, 0x53, 0xbb, 0x9f,
	0x5e, 0xf5, 0xb4, 0x49, 0x38, 0x96, 0x35, 0x9e, 0x41, 0x25, 0xf9, 0xda, 0xc2, 0xcf, 0xcc, 0xf8,
	0x80, 0x96, 0x9f, 0x04, 0xe3, 0x61, 0xf2, 0xeb, 0x50, 0x26, 0xfd, 0x75, 0x08, 0x41, 0x6e, 0xec,
	0x05, 0x23, 0xb1, 0xca, 0x45, 0x2c, 0xfe, 0x1b, 0x7f, 0xd5, 0x20, 0x6f, 0x3e, 0xe7, 0x9d, 0xca,
	0x07, 0x90, 0xbb, 0xa4, 0xbe, 0xab, 0xca, 0x4c, 0xba, 0xe3, 0x17, 0x12, 0xf2, 0xf7, 0x29, 0xf5,
	0x5d, 0x2c, 0x24, 0xd1, 0x11, 0x6c, 0x24, 0x5a, 0x90, 0x54, 0xa7, 0x72, 0x63, 0xe3, 0x81, 0x96,
	0x1a, 0x8b, 0x38, 0x6a, 0x40, 0x61, 0x42, 0x18, 0xe3, 0x1d, 0xa2, 0x0c, 0xe6, 0x78, 0x68, 0x7c,
	0x06, 0xa5, 0xc5, 0xa4, 0xfc, 0x36, 0x6f, 0x62, 0xdc, 0xe7, 0x97, 0xfc, 0x32, 0x14, 0xbe, 0x6a,
	0xe1, 0x9e, 0xbc, 0xe5, 0x17, 0x21, 0xd7, 0xe9, 0x1d, 0xf5, 0xf5, 0x2c, 0xbf, 0x22, 0x9f, 0xe0,
	0xfe, 0x31, 0x36, 0x07, 0x03, 0x3d, 0x77, 0xf0, 0x31, 0x3c, 0x76, 0x82, 0xc9, 0xee, 0x38, 0x08,
	0xc6, 0x1e, 0xd9, 0x75, 0xc9, 0xf3, 0x28, 0x08, 0x3c, 0xb6, 0x2b, 0xbf, 0xba, 0x7a, 0x74, 0xb4,
	0x2b, 0x4c, 0xdb, 0x97, 0x1f, 0x60, 0xe5, 0xef, 0xbe, 0x3d, 0xa5, 0xff, 0x0e, 0x00, 0x00, 0xff,
	0xff, 0x53, 0xe5, 0xbe, 0x1e, 0xc3, 0x1d, 0x00, 0x00,
}
